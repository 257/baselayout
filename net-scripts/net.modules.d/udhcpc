# udhcpc (net-misc/udhcp) module for net-scripts
# Version 1.0.3
# Copyright (c) 2004 Gentoo Foundation
# Distributed under the terms of the GNU General Public License V2
# Contributed by Roy Marples (uberlord@gentoo.org)

# Fix any potential localisation problems
# Note that LC_ALL trumps LC_anything_else according to locale(7)
udhcpc() {
	LC_ALL=C /sbin/udhcpc "$@"
}

# char* udhcpc_provides(void)
#
# Returns a string to change module definition for starting up
udhcpc_provides() {
	echo "dhcp"
}

# void udhcpc_depend(void)
#
# Sets up the dependancies for the module
udhcpc_depend() {
	after interface
	need interface
}

# bool udhcpc_check_installed(void)
#
# Returns 1 if udhcpc is installed, otherwise 0
udhcpc_check_installed() {
	[[ -x /sbin/udhcpc ]] && return 0
	[[ ${1} == true ]] && eerror "For DHCP (udhcpc) support, emerge net-misc/udhcp"
	return 1
}

# char* udhcpc_get_script(void)
#
# Returns the filename of the script to run
udhcpc_get_script() {
	local module=$( interface_module )
	echo "/lib/rcscripts/net.modules.d/helpers.d/udhcpc-${module}"
}

# bool udhcpc_check_depends(void)
#
# Checks to see if we have the needed functions
udhcpc_check_depends() {
	local f

	for f in interface_variable interface_device interface_is_up interface_get_address interface_module; do
		[[ $(type -t ${f}) == function ]] && continue
		eerror "udhcpc: missing required function ${f}\n"
		return 1
	done

	return 0
}

# char* udhcpc_get_vars(char *interface)
#
# Returns a string spaced with possible user set
# configuration variables
udhcpc_get_vars() {
	echo "udhcpc_${1} peer_dns_${1} peer_nis_${1} peer_ntp_${1}"
}

# bool udhcpc_stop(char *iface)
#
# Stop DHCP on an interface by calling udhcpc -z $iface
#
# Returns 0 (true) when a DHCP address dropped
# otherwise return 1
udhcpc_stop() {
	local iface=${1} count script=$( udhcpc_get_script )
	
	udhcpc_check_installed || return 1

	# We check for a udhcpc process first as if we attempt to release
	# an interface for which udhcpc has obtained an IP in the past
	# it causes a "RELEASE" event anyway.
	local r=$( ps -fC udhcpc | awk "/--interface=${iface}/" | awk '{print $2}' )
	[[ -z ${r} ]] && return 1

	ebegin "Releasing DHCP lease for ${iface}"
	local pid addr i
	for pid in ${r}; do
		kill -s SIGUSR2 ${pid}
# Current portage version does not process SIGUSR2 properly
# so we don't use this code atm
#		i=0
#		while (( i < 30 )); do
#			addr=$( interface_get_address ${iface} )
#			[[ -z ${addr} ]] && break
#			(( i++ ))
#			sleep 1
#		done
		# For some reason we have no mech of removing the process, so
		# we have to kill it
		kill -s KILL ${pid} &>/dev/null
	done

	r=$( ps -fC udhcpc | awk "/--interface=${iface}/ {print \$1}")
	[[ -z ${r} ]]
	eend $?

	return 0
}

# bool udhcpc_start(char *iface)
#
# Start DHCP on an interface by calling udhcpc $iface $options
#
# Returns 0 (true) when a DHCP address is obtained, otherwise 1
udhcpc_start() {
	local iface=${1} opts hostname
	local ifvar=$( get_interface_variable ${iface} )

	! interface_exists ${iface} true && return 1

	# Check that iface was not brought up by the kernel ...
	local check=$( interface_device ${iface} )
	if [[ ${check} == ${iface} ]] && interface_is_up ${iface} true ; then
		einfo "Keeping kernel configuration for ${iface}"
		return 0
	fi

	local script=$( udhcpc_get_script )

	eval opts=\"\$\{udhcpc_${ifvar}\}\"
	hostname=$( hostname )
	[[ -n ${hostname} ]] && hostname="--hostname=${hostname%%.*}"

	# Bring up DHCP for this interface (or alias)
	local r=$( udhcpc ${hostname} ${opts} --script=${script} --now --interface=${iface} )
	# We just check the last 5 letters
	[[ ${r:((${#r} - 5)):5} == BOUND ]]
	eend $? "udhcpc recieved a ${r}" || return 1

	# DHCP succeeded, show address retrieved
	local addr=$( interface_get_address ${iface} )
	einfo "${iface} received address ${addr}"
	return 0
}
