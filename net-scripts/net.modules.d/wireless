# Wireless module for net-scripts
# Version 1.0.0
# Copyright (c) 2004 Gentoo Foundation
# Distributed under the terms of the GNU General Public License V2
# Contributed by Roy "UberLord" Marples (uberlord@rsm.demon.co.uk)

# Load our config if it exists
[[ -f /etc/conf.d/wireless ]] && source /etc/conf.d/wireless

# Fix any potential localisation problems
# Note that LC_ALL trumps LC_anything_else according to locale(7)
iwconfig() {
	LC_ALL=C /usr/sbin/iwconfig "$@"
}
iwgetid() {
	LC_ALL=C /usr/sbin/iwgetid "$@"
}
iwlist() {
	LC_ALL=C /usr/sbin/iwlist "$@"
}
iwpriv() {
	LC_ALL=C /usr/sbin/iwpriv "$@"
}

# void wireless_depend(void)
#
# Sets up the dependancies for the module
wireless_depend() {
	before interface
	need interface
}

# bool wireless_check_installed(void)
#
# Returns 1 if wireless-tools is installed, otherwise 0
wireless_check_installed() {
	[[ -x /usr/sbin/iwconfig ]] && return 0
	[[ ${1} == true ]] && eerror "For Wireless (802.11) support, emerge net-wireless/wireless-tools"
	return 1
}

# char* wireless_provides(void)
#
# Returns a string to change module definition for starting up
wireless_provides() {
	echo "wireless"
}

# bool wireless_check_depends(void)
#
# Checks to see if we have the needed functions
wireless_check_depends() {
	local f

	for f in interface_up interface_down interface_del_addresses; do
		[[ $(type -t ${f}) == function ]] && continue
		eerror "wireless: missing required function ${f}\n"
		return 1
	done

	return 0
}

# bool wireless_check_extensions(char *interface)
#
# Checks to see if wireless extensions are enabled on the interface
wireless_check_extensions() {
	local iface=${1}

	# Do we have wireless extensions enabled on the interface?
	local ext=$(iwconfig ${iface} 2>/dev/null | awk -v iface=${iface} '{ if ($1 == iface) print "yes" }')
	[[ ${ext} == yes ]]
	return $?
}

# char* wireless_wep_status(char *interface)
#
# Echos a string showing whether WEP is enabled or disabled
# for the given interface
wireless_wep_status() {
	local wep_status=$( iwconfig ${1} | awk -F: '/Encryption key:/ {print $2}' | awk '{if ($1 != "off") print "enabled"}' )
	wep_status=${wep_status:-"disabled"}
	echo "(WEP ${wep_status})"
}

# char* wireless_get_essid(char *iface)
#
# Gets the current ESSID of the iface
wireless_get_essid() {
	# Too many users are having with iwgetid atm :/
	# iwgetid -r

	iwconfig ${1} 2>${devnull} | awk -F\" '/ESSID/ {print $2}'
}

# char* wireless_get_ap_mac_address(char *interface)
#
# Returns the MAC address of the Access Point
# the interface is connected to
wireless_get_ap_mac_address() {
	iwgetid --ap ${1} 2>${devnull}| awk '{print $4}'
}

# char* wireless_get_mode(char *interface)
#
# Returns the wireless mode in lower case
wireless_get_mode() {
	iwgetid -m ${1} | awk -F: '{print $2}' | tr '[:upper:]' '[:lower:]'
}

# char* wireless_get_type(char *interface)
#
# Returns the type of interface - the IEEE part
wireless_get_type() {
	iwconfig ${1} 2>/dev/null | awk '{print $2,$3}'
}

# void wireless_report(char *interface)
#
# Output how our wireless interface has been configured
# Sometimes iwgetid fails - or shows strange characters
# I think this is more of a driver issue at this time
wireless_report() {
	local iface=${1} mac mode m="as"
	local essid

	# We do this so that we get a 100% valid report
	while true ; do
		essid=$( wireless_get_essid ${iface} )
		[[ -n ${essid} ]] && break
		sleep 1
	done

	local wep_status=$( wireless_wep_status ${iface} )

	# Displays some info about how we are connected
	local channel=$( iwlist ${iface} channel 2>/dev/null | awk '/Current/' | sed 's/^.*hannel[ :]\(.*\)[0-9]*.*$/\1/g' )
	channel=${channel//[![:digit:]]/}	

	essid=${essid//\\\\/\\\\}
	local mode=$( wireless_get_mode ${iface} )
	if [[ ${mode} == managed ]]; then
		m="to"
		mac=$( wireless_get_ap_mac_address ${iface} )
		mac=" at ${mac}"
	fi
	
	einfo "    ${iface} connected ${m} \"${essid}\"${mac}"
	einfo "    in ${mode} mode on channel ${channel} ${wep_status}"
}

# char* wireless_get_essid_var(void)
#
# Formats the essid so it can be used by bash variables
# Basically it replaces any non alphanumeric character with a _ symbol
wireless_get_essid_var() {
	echo ${ESSID//[![:word:]]/_}
}

# char* wireless_get_wep_key(char *mac_address)
#
# Returns the configured WEP key for the given mac address
# or the given ESSID. The mac address setting takes precendence
wireless_get_wep_key() {
	local mac=${1} essid=$( wireless_get_essid_var ) key
	eval key=\"\${mac_key_${mac//:/}\}\"
	[[ -z ${key} ]] && eval key=\"\${key_${essid}\}\"
	key=${key:-off}
	echo ${key}
}

# void wireless_user_config(char *iface)
#
# Applies the user configuration to the interface
wireless_user_config() {
	local iface=${1} conf e

	# Apply the user configuration
	eval conf=\"\$\{iwconfig_${iface}\}\"
        if [[ -n ${conf} ]]; then
                e=$( iwconfig ${iface} ${conf} 2>&1 )
		if [[ -n ${e} ]]; then
			ewarn "  ${iface} does not support the following configuration commands"
			ewarn "    \"${conf}\""
		fi
        fi

	eval conf=\"\$\{iwpriv_${iface}\}\"
        if [[ -n ${conf} ]]; then
		e=$( iwpriv ${iface} ${conf} 2>&1 )
		if [[ -n ${e} ]]; then
			ewarn "  ${iface} does not support the following private ioctls"
			ewarn "    \"${conf}\""
		fi
        fi
}

# void wireless_setup_iface(char *iface)
#
# All interfaces and module scripts expose modulename_get_vars
# which returns a space seperated list of user configuration variables
# We can override each variable here from a given ESSID or the MAC
# of the AP connected to. MAC configuration takes precedence
wireless_setup_iface() {
	local iface=${1}
	local mod func evars evar vars x i mvars mac=$( wireless_get_ap_mac_address ${iface} )
	local essid=$( wireless_get_essid_var )
	mac=${mac//:/}

	for mod in ${MODULES[@]}; do
		func="${mod}_get_vars"
		if [[ $(type -t ${func}) == function ]]; then
			evars=( $( ${func} ${essid} ) )
			mvars=( $( ${func} ${mac} ) )
			vars=( $( ${func} ${iface} ) )
			for ((i = 0; i<${#mvars[@]}; i++)); do
				eval x=( \"\$\{mac_${mvars[i]}\[@\]\}\" )
				[[ -z ${x} ]] && eval x=( \"\$\{${evars[i]}\[@\]\}\" )
				[[ -n ${x} ]] && eval "${vars[i]}=( "\"\$\{x\[@\]\}\"" )"
			done
		fi
	done

	# Nameserver setup for the essid if required
	local -a nameservers=( \"\$\{mac_nameservers_${mac}\[@\]\}\" )
	[[ -z ${nameservers} ]] && eval nameservers=( \"\$\{nameservers_${essid}\[@\]\}\" )
	if [[ -n ${nameservers} ]]; then
		# Make a backup of the origional file if necessary
		[[ -f /etc/resolv.conf ]] && mv /etc/resolv.conf /etc/resolv.conf.sv
		echo "# Generated by net-scripts wireless module" > /etc/resolv.conf
		chmod 644 /etc/resolv.conf
		for x in ${nameservers[@]}; do
			echo "nameserver ${x}" >> /etc/resolv.conf
		done
		eval x=\"\$\{mac_domain_${mac}\}\"
		[[ -z ${x} ]] && eval x=\"\$\{domain_${essid}\}\"
		if [[ -n ${x} ]]; then
			echo "domain ${x}" >> /etc/resolv.conf
			echo "search ${x}" >> /etc/resolv.conf
		fi
	fi

	# Backwards compat for old gateway var
	eval x=\"\$\{gateway_${essid}\}\"
	[[ -n ${x} ]] && gateway="${iface}/${x}"
}

# bool wireless_setup_specific(char *iface)
#
# Sets up our wireless interface to operate in ad-hoc or master mode
wireless_setup_specific() {
	local iface=${1} mode=${2} channel key dessid e

	if [[ -z ${ESSID} ]]; then
		eerror "  ${iface} requires an ESSID to be set to operate in ${mode} mode"
		eerror "  adjust the essid_${iface} setting in /etc/conf.d/wireless"
		return 1
	fi
	dessid=${ESSID//\\\\/\\\\}

        # We only change the mode if it's not the same
        local cur_mode=$( wireless_get_mode ${iface} )
        if [[ ${cur_mode} != ${mode} ]]; then
                e=$( iwconfig ${iface} mode ${mode} 2>&1 )
                if [[ -n ${e} ]]; then
                        eerror "${iface} does not support setting the mode to \"${mode}\""
                        return 1
                fi
        fi

	key=$( wireless_get_wep_key )
	e=$( iwconfig ${iface} key ${key} 2>&1 )
	if [[ -n ${e} && ${key} != off ]]; then
		e=$( get_essid_var ${essid} )
		ewarn "  ${iface} does not support setting keys"
		ewarn "  or the parameter \"mac_key_${e}\" or \"key_${e}\" is incorrect"
	fi

	e=$( iwconfig ${iface} essid "${ESSID}" 2>&1 )
	if [[ -n ${e} ]]; then
		eerror "  ${iface} does not support setting ESSID to \"${dessid}\""
		return 1
	fi
	iwconfig ${iface} nick "${ESSID}" 2>/dev/null

	eval channel=\"\$\{channel_${iface}\}\"
	# We default the channel to 3
	channel=${channel:-3}

	e=$( iwconfig ${iface} channel ${channel} 2>&1 )
	if [[ -n ${e} ]]; then
		eerror ${e}
		ewarn "  ${iface} does not support setting the channel to \"${channel}\""
		return 1
	fi

	wireless_user_config ${iface}
	wireless_setup_iface ${iface}
	wireless_report ${iface}

	return 0
}

# bool wireless_associate_mac(char *iface)
#
# Returns true if the AP MAC address is valid or not
wireless_associate_mac() {
	# Checks if a MAC address has been assigned
	local mac=$( wireless_get_ap_mac_address ${1} ) i
	local -a invalid_macs=( "00:00:00:00:00:00" "44:44:44:44:44:44" "FF:00:00:00:00:00" "FF:FF:FF:FF:FF:FF" )

	[[ -z ${mac} ]] && return 1
	for i in ${invalid_macs[@]}; do
		[[ ${i} == ${mac} ]] && return 1
	done
	return 0
}

# bool wireless_associate_quality(char *iface)
#
# Returns true if the link quality is not 0 or 0.
wireless_associate_quality() {
	local quality=$( cat /proc/net/wireless | awk -v IFACE=${1}: '{ if ($1 == IFACE) print $3 }' )
	[[ ${quality} != 0 && ${quality} != 0. ]] && return 0
	return 1
}

# bool wireless_test_associated(char *iface)
#
# Returns true if the interface has associated with an Access Point
wireless_test_associated() {
	local iface=${1} test
	# Some drivers don't set MAC to a bogus value when assocation is lost/fails
	# whereas they do set link quality to 0

	test=$( eval echo \$\{associate_test_${iface}\} | tr '[:upper:]' '[:lower:]' )
	test=${test:-mac}
	if [[ ${test} != mac && ${test} != quality && ${test} != all ]]; then
		ewarn "    associate_test_${iface} is not set to mac, quality or all"
		ewarn "    defaulting to \"mac\""
		test=mac
	fi

	case ${test} in
		mac) wireless_associate_mac ${iface} && return 0 ;;
		quality) wireless_associate_quality ${iface} && return 0 ;;
		all) wireless_associate_mac ${iface} && wireless_associate_quality ${iface} && return 0 ;;
	esac

	return 1
}

# bool wireless_wait_for_association(char *iface)
#
# Waits for a configured ammount of time until
# we are assocaited with an Access Point
wireless_wait_for_association() {
	local iface=${1} i=0 wait
	eval wait=\"\$\{sleep_associate_${iface}\}\"
	wait=${wait:-10}

	while (( i<wait )); do
		wireless_test_associated ${iface} && return 0
		sleep 1
		(( i++ ))
	done
	return 1
}

# bool wireless_associate(char *interface, char *mac_address, char *wep_required)
#
# Tries to associate the interface with an Access Point
# If we scanned the Access Point we know if we need WEP to associate or not
# and if we have a WEP key for the ESSID or not
# so we can fail gracefully without even trying to connect
wireless_associate() {
	local iface=${1} mac=${2} wep_required=${3} w="(WEP Disabled)"
	local dessid=${ESSID//\\\\/\\\\} key=$( wireless_get_wep_key ${mac} )
	wep_required=${wep_required:-"off"}

	if [[ ${ESSID} == any ]]; then
		iwconfig ${iface} ap any 2>/dev/null
		dessid="any"
	else
		if [[ ${wep_required} == yes && ${key} == off ]]; then
			ewarn "  WEP key is not set for \"${dessid}\" - not connecting"
			return 1
		fi
		if [[ ${wep_required} == no && ${key} != off ]]; then
			key="off"
			ewarn "  \"${dessid}\" is not WEP enabled - ignoring setting"
		fi
		e=$( iwconfig ${iface} key ${key} 2>&1 )
		if [[ -n ${e} && ${key} != off ]]; then
			e=$( wireless_get_essid_var ${essid} )
			ewarn "  ${iface} does not support setting keys"
			ewarn "  or the parameter \"mac_key_${e}\" or \"key_${e}\" is incorrect"
			return 1
		fi
		[[ ${key} != off ]] && w="(WEP enabled)"
	fi

	e=$( iwconfig ${iface} essid "${ESSID}" 2>&1 )
	[[ -n ${e} && ${ESSID} != any ]] && ewarn "  ${iface} does not support setting ESSID to \"${dessid}\""
	iwconfig ${iface} nick "${ESSID}" 2>/dev/null

	ebegin "  Connecting to \"${ESSID//\\\\//}\" ${w}"
	if ! wireless_wait_for_association ${iface} ; then
		eend 1
		return 1
	fi
	eend 0

	if [[ ${ESSID} == any ]]; then
		ESSID=$( get_essid ${iface} )
		wireless_associate ${iface}
		return $?
	fi

	wireless_user_config ${iface}	
	wireless_setup_iface ${iface}
	wireless_report ${iface}
	return 0
}

# bool wireless_scan(char *iface)
#
# Fills 3 arrays with information from a wireless scan
wireless_scan() {
	local iface=${1} e mode x

	# First, we may need to change mode to scan in
	mode=$( eval echo \$\{scan_mode_${iface}\} | tr '[:upper:]' '[:lower:]' )
	if [[ -n ${mode} ]]; then
		e=$( iwconfig ${iface} mode ${mode} 2>&1 )
		[[ -n ${e} ]] && ewarn "  ${iface} does not support setting the mode to \"${mode}\""
	fi

	# Next we set any private driver ioctls needed
	eval x=\"\$\{iwpriv_scan_pre_${iface}\}\"
	if [[ -n ${x} ]]; then
		e=$( iwpriv ${iface} ${x} 2>&1 )
		if [[ -n ${e} ]]; then
			ewarn "  ${iface} does not support the following private ioctls" \
			ewarn "    \"${x}\""
		fi
	fi

	einfo "  Scanning for access points"

	# Sleep if required
	eval x=\"\$\{sleep_scan_${iface}\}\"
	[[ -n ${x} ]] && sleep ${x}

	local scan=$( iwlist ${iface} scanning 2>/dev/null )

	# We may need to unset the previous private driver ioctls
	eval x=\"\$\{iwpriv_scan_post_${iface}\}\"
	if [[ -n ${x} ]]; then
		e=$( iwpriv ${iface} ${x} 2>&1 )
		if [[ -n ${e} ]]; then
			ewarn "  ${iface} does not support the following private ioctls" \
			ewarn "    \"${x}\""
		fi
	fi

	# Change back to the managed mode if needed
	[[ ${mode} != managed ]] && iwconfig ${iface} mode managed 2>${devnull}

	if [[ -z ${scan} ]]; then
		ewarn "${iface} does not support scanning"
		eval x=\"\$\{adhoc_essid_${iface}\}\"
		[[ -n ${preferred_aps} || -n ${x} ]] && return 0
		eerror "You either need to set a preferred_aps list in /etc/conf.d/wireless"
		eerror "   preferred_aps=( \"ESSID1\" \"ESSID2\" )"
		eerror "or configure defaulting to Ad-Hoc when Managed fails"
		eerror "   adhoc_essid_${iface}=\"WLAN\""
		eerror "or hardcode the ESSID against the interface (not recommended)"
		eerror "    essid_${iface}=\"ESSID\""
		return 1
	fi

	local val i=-1 IFS=$'\n' j last
	local -a qual

	# OK - we need ESSID, MAC address and encryption from just one call to iwlist $iface scan
	# It has to be one call for speed reasons as some cards take ages to get a list from
	# It's clumsy (imo) but it works
	for val in ${scan}; do
		local t=$( echo ${val} | awk -F: '/ESSID/ {print $2}' )
		if [[ ${#t} -gt 2 ]]; then
			t=${t#*\"}
			essid_APs[i]=${t%*\"}
		else
			t=$( echo ${val} | awk '/Address/ {print}' | sed 's/^.*\<\(..:..:..:..:..:..\)\>.*$/\1/g' )
			if [[ ${#t} -gt 0 ]]; then
				((i++))
				mac_APs[i]=${t}
				essid_APs[i]=""
				enc_APs[i]=no
				qual[i]=0
			else
				t=$( echo ${val} | awk -F: '/Encryption key/ {print $2}' )
				if [[ ${#t} -gt 0 ]]; then
					if [[ ${t} == off ]]; then
						enc_APs[i]=no
					else
						enc_APs[i]=yes
					fi
				else
					t=$( echo ${val} | awk -F: '/Quality/ {print $2}' )
					if [[ ${#t} -gt 0 ]]; then
						# Not all drivers report the same way, so we take the below measure
						# to ensure we don't error on the sort below
						t=${t# *}
						t=${t%/*}
						t=${t//[![:digit:]]/}
						qual[i]=${t:-0}
					fi
				fi
			fi
		fi
	done

	# Now sort the AP's by quality
	for ((last=${#mac_APs[@]}-1; last>0; last--)); do
		for ((i=0; i<${last}; i++)); do
			(( j = i + 1 ))
			if [[ ${qual[i]} -lt ${qual[j]} ]]; then
				t=${mac_APs[i]}
				mac_APs[i]=${mac_APs[j]}
				mac_APs[j]=${t}
				t=${essid_APs[i]}
				essid_APs[i]=${essid_APs[j]}
				essid_APs[j]=${t}
				t=${enc_APs[i]}
				enc_APs[i]=${enc_APs[j]}
				enc_APs[j]=${t}
				t=${qual[i]}
				qual[i]=${qual[j]}
				qual[j]=${t}
			fi
		done
	done

	return 0
}

# void wireless_scan_report(void)
#
# Report the results of the scan and re-map any ESSIDs if they
# have been configured for the MAC address found
wireless_scan_report() {
	local i k m remove
	local -a u

	[[ -z ${mac_APs} ]] && ewarn "    no access points found"

	# We need to do the for loop like this so we can
	# dynamically remove from the array
	for ((i=0; i<${#mac_APs[@]}; i++)); do
		k=""
		[[ ${enc_APs[i]} == yes ]] && k="(WEP required)"

		if [[ -z ${essid_APs[i]} ]]; then
			einfo "    Found ${mac_APs[i]} ${k}"
		else
			einfo "    Found \"${essid_APs[i]//\\\\/\\\\}\" at ${mac_APs[i]} ${k}"
		fi

		eval m=\"\$\{mac_essid_${mac_APs[i]//:/}\}\"
		if [[ -n ${m} ]]; then
			essid_APs[i]=${m}
			einfo "      mapping to \"${m//\\\\/\\\\}\""
		fi

		remove=false
		# If we don't know the essid then we cannot connect to them
		# so we remove them from our array
		if [[ -z ${essid_APs[i]} ]]; then
			remove=true
		else
			for k in "${blacklist_aps[@]}"; do
				if [[ ${k} == ${essid_APs[i]} ]]; then
					ewarn "      \"${k//\\\\/\\\\}\" has been blacklisted - not connecting"
					remove=true
					break
				fi
			done
		fi
		${remove} && u=( "${u[@]}" "${i}" )
	done

	# Now we remove any duplicates
	for ((i=0; i < ${#essid_APs[@]} - 1; i++)); do
		for ((j=${i} + 1; j <${#essid_APs[@]}; j++)); do
			[[ ${essid_APs[i]} == ${essid_APs[j]} ]] && u=( "${u[@]}" "${j}" )
		done
	done

	for i in ${u[@]}; do
		unset essid_APs[i]
		unset mac_APs[i]
		unset enc_APs[i]
	done

	# We need to squash our arrays so indexes work again
	essid_APs=( "${essid_APs[@]}" )
	mac_APs=( "${mac_APs[@]}" )
	enc_APs=( "${enc_APs[@]}" )
}

# bool wireless_force_preferred(char *iface)
#
# Forces the preferred_aps list to associate in order
# but only if they were not picked up by our scan
wireless_force_preferred() {
	local iface=${1} essid i

	[[ -z ${preferred_aps} ]] && return 1

	ewarn "  Trying to force preferred incase they are hidden"
	for essid in "${preferred_aps[@]}"; do
		local found_AP=false
		for ((i = 0; i < ${#mac_APs[@]}; i++)); do
			if [[ ${essid} == ${essid_APs[i]} ]]; then
				found_AP=true
				break
			fi
		done
		if ! ${found_AP} ; then
			ESSID=${essid}
			wireless_associate ${iface} && return 0
		fi
	done

	ewarn "  Failed to associate with any preferred access points on ${iface}"
	return 1
}

# bool wireless_connect_preferred(char *iface)
#
# Connects to preferred_aps in order if they were picked up
# by our scan
wireless_connect_preferred() {
	local iface=${1} essid i

	for essid in "${preferred_aps[@]}"; do
		for ((i=0; i<${#essid_APs[@]}; i++)); do
			if [[ ${essid} == ${essid_APs[i]} ]]; then
				ESSID=${essid}
				wireless_associate ${iface} ${mac_APs[i]} ${enc_APs[i]} && return 0
				break
			fi
		done
	done

	return 1
}

# bool wireless_connect_not_preferred(char *iface)
#
# Connects to any AP's found that are not in
# our preferred list
wireless_connect_not_preferred() {
	local iface=${1} i ap has_preferred

	for ((i=0; i<${#mac_APs[@]}; i++)); do
		has_preferred=false
		for ap in "${preferred_aps[@]}"; do
			if [[ ${ap} == ${essid_APs[i]} ]]; then
				has_preferred=true
				break
			fi
		done
		if ! ${has_preferred} ; then
			ESSID=${essid_APs[i]}
			wireless_associate ${iface} ${mac_APs[i]} ${enc_APs[i]} && return 0
		fi
	done

	return 1
}

# void wireless_defaults(char *iface)
#
# Apply some sane defaults to the wireless interface
# incase the user already applied some changes
wireless_defaults() {
	local iface=${1}

	# Set some defaults
	iwconfig ${iface} rate auto &>/dev/null
	iwconfig ${iface} rts off &>/dev/null
	iwconfig ${iface} frag off &>/dev/null
	iwconfig ${iface} power off &>/dev/null
	iwconfig ${iface} txpower auto &>/dev/null
	iwconfig ${iface} key off &>/dev/null

	# We need to set the essid to any as some drivers won't
	# scan correctly if they are already set to an ESSID
	iwconfig ${iface} essid any &>/dev/null
}

# void wireless_strip_associated(char *iface)
#
# We check to see which ifaces have associated AP's except for the iface
# given and remove those AP's from the scan list
# We also remove from the preferred list
wireless_strip_associated() {
	local iface=${1} e a j
	local essid=$( iwconfig ${iface} | awk -F\" '/ESSID/ {print $2}' )
	local -a ifaces=( $( iwconfig 2>/dev/null | awk '/ESSID/ {print $1}' | awk -v IFACE=${iface} '$1!=IFACE {print}' ) )

	for i in "${ifaces[@]}"; do
		wireless_test_associated ${i} || continue
		e=$( iwconfig ${i} | awk -F\" '/ESSID/ {print $2}' )
		u=()
		for ((j=0; j<${#mac_APs[@]}; j++)); do
			if [[ ${essid_APs[j]} == ${e} ]]; then
				ewarn "    ${e} has already been associated with ${i}"
				unset essid_APs[j]
				unset mac_APs[j]
				unset enc_APs[j]
				# We need to squash our arrays so that indexes work
				essid_APs=( "${essid_APs[@]}" )
				mac_APs=( "${mac_APs[@]}" )
				enc_APs=( "${enc_APs[@]}" )
				break
			fi
		done
		for ((j=0; j<${#preferred_aps[@]}; j++)); do
			if [[ ${preferred_aps[j]} == ${e} ]]; then
				unset preferred_aps[j]
				preferred_aps=( "${preferred_aps[@]}" )
				break
			fi
		done
	done
}

# bool wireless_configure(char *iface)
#
# The main startup code
# First we bring the interface up, apply defaults, apply user configuration
# Then we test to see if ad-hoc mode has been requested and branch if needed
# Then we scan for access points and try to connect to them in a predetermined order
# Once we're connected we show a report and then configure any interface
# variables for the ESSID
wireless_configure() {
	local iface=${1} ESSID test e x
	local -a essid_APs mac_APs enc_APs

	# We need to bring the interface up to apply stuff
	interface_up ${iface}

	# Are we a proper IEEE device?
	e=$( wireless_get_type ${iface} )
	if [[ ${e%% *} != IEEE ]]; then
		eerror "Looks like there was a probem loading the firmware for ${iface}"
		return 1
	fi
	
	wireless_defaults ${iface}

	eval ESSID=\"\$\{essid_${iface}\}\"

	# Setup ad-hoc mode?
	x=$( eval echo \$\{mode_${iface}\} | tr '[:upper:]' '[:lower:]' )
	x=${x:-managed}
	if [[ ${x} == ad-hoc || ${x} == master ]]; then
		wireless_setup_specific ${iface} ${x}
		return $?
	fi

	if [[ ${x} != managed ]]; then
		eerror "Only managed, ad-hoc and master modes are supported"
		return 1
	fi

	# We only change the mode if it's not the same as some drivers
	# only do managed and throw an error changing to managed
	local cur_mode=$( wireless_get_mode ${iface} )
	if [[ ${cur_mode} != ${x} ]]; then
		e=$( iwconfig ${iface} mode ${x} 2>&1 )
		if [[ -n ${e} ]]; then
			eerror "${iface} does not support setting the mode to \"${x}\""
			return 1
		fi
	fi

	# These arrays hold the results of our scan
	local -a mac_APs essid_APs enc_APs

	# Has an ESSID been forced?
	if [[ -n ${ESSID} ]]; then
		wireless_associate ${iface} && return 0
		[[ ${ESSID} == any ]] && wireless_force_preferred ${iface} && return 0

		eval ESSID=\"\$\{adhoc_essid_${iface}\}\"
		if [[ -n ${ESSID} ]]; then
			wireless_setup_specific ${iface} ad-hoc
			return $?
		fi
		return 1
	fi

	# Do we have a preferred Access Point list specific to the interface?
	eval e=( \"\$\{preferred_aps_${iface}\[@\]\}\" )
	[[ -n ${e} ]] && preferred_aps=( "${e[@]}" )

	# Do we have a blacklist Access Point list specific to the interface?
	eval e=( \"\$\{blacklist_aps_${iface}\[@\]\}\" )
	[[ -n ${e} ]] && blacklist_aps=( "${e[@]}" )

	# Are we forcing preferred only?
	eval e=\"\$\{preferred_only_${iface}\}\"
	[[ -n ${e} ]] && preferred_only=${e}
	preferred_only=$( echo ${preferred_only:-no} | tr '[:upper:]' '[:lower:]' )

	if [[ ${preferred_only} == force ]]; then
		wireless_force_preferred ${iface} && return 0
	else
		wireless_scan ${iface} || return 1
		wireless_scan_report

		# Strip AP's from the list that have already been associated with
		# other wireless cards in the system if requested
		eval e=\"\$\{unique_ap_${iface}\}\"
		[[ -n ${e} ]] && unique_ap=${e}
		unique_ap=$( echo ${unique_ap:-no} | tr '[:upper:]' '[:lower:]' )
		[[ no != ${unique_ap} ]] && wireless_strip_associated ${iface}

		wireless_connect_preferred ${iface} && return 0
		wireless_force_preferred ${iface} && return 0
		[[ ${preferred_only} == no ]] && wireless_connect_not_preferred ${iface} && return 0
	fi

	e="associate with"
	[[ -z ${mac_APs} ]] && e="find"
	[[ ${preferred_only} == force ]] && e="force"
	e="  Couldn't ${e} any access points on ${iface}"
	
	eval ESSID=\"\$\{adhoc_essid_${iface}\}\"
	if [[ -n ${ESSID} ]]; then
		ewarn ${e}
		wireless_setup_specific ${iface} ad-hoc
		return $?
	fi

	eerror ${e}
	return 1
}

# bool wireless_pre_start(char *iface)
#
# Start entry point
# First we check if wireless extensions exist on the interface
# If they are then we configue wireless
wireless_pre_start() {
	local iface=${1} r=0 local wasup=true

	if ! wireless_check_extensions ${iface} ; then
		if ! interface_is_up ${iface} ; then
			interface_up ${iface}
			wasup=false
		fi
		if ! wireless_check_extensions ${iface} ; then
			einfo "  Wireless extensions not found for ${iface}"
			! ${wasup} && interface_down ${iface}
			return 0
		fi
	fi

	einfo "  Configuring wireless network for ${iface}"

	# Setup IFS incase parent script has modified it
	local IFS=$' '$'\n'$'\t'

	if wireless_configure ${iface} ; then
		# This causes DHCP to work - and we don't have to take down the interface
		# which makes things a lot faster
		interface_del_addresses ${iface}
		return 0
	fi

	eerror "Failed to configure wireless for ${iface}"
	wireless_defaults ${iface}
	unset ESSID
	interface_down ${iface}
	return 1
}

# bool wireless_post_stop(char *iface)
#
# Removes wireless configuration if applicable
# Always returns 0
wireless_post_stop() {
	local iface=${1} wasup=true

	if ! interface_is_up ${iface} ; then
		interface_up ${iface}
		wasup=false
	fi

        if wireless_check_extensions ${iface} ; then
		# Set the ESSID var for use in any postdown functions
		ESSID=$( iwconfig ${iface} | awk -F\" '/ESSID/ {print $2}' )

		ebegin "  Removing wireless configuration from ${iface}"
		wireless_defaults ${iface}
		eend 0
	fi

	! ${wasup} && interface_down ${iface}

	return 0
}
