# Pump module for net-scripts
# Copyright 2004 Gentoo Foundation
# Distributed under the terms of the GNU General Public License v2
# Contributed by Roy "UberLord" Marples <uberlord@rsm.demon.co.uk>
# $Header$

# Fix any potential localisation problems
# Note that LC_ALL trumps LC_anything_else according to locale(7)
pump() {
        LC_ALL=C /sbin/pump "$@"
}

# char* pump_provides(void)
#
# Returns a string to change module definition for starting up
pump_provides() {
	echo "dhcp"
}

# bool pump_check_installed(void)
#
# Returns 1 if pump is installed, otherwise 0
pump_check_installed() {
	[[ -x /sbin/pump ]] && return 0
	[[ true == ${1} ]] && eerror "For DHCP (pump) support, emerge net-misc/pump"
	return 1
}

# bool pump_check_depends(void)
#
# Checks to see if we have the necessary package installed
# and the handler supports the necessary functionality
pump_check_depends() {
	local e

	[[ function != $(typeset -f interface_get_status) ]] && e=interface_get_status
	[[ function != $(typeset -f interface_get_address) ]] && e=interface_get_address
	[[ -z ${e} ]] && return 0

	eerror "pump: interface is missing the required function ${e}\n"
	return 1
}

# char* pump_get_vars(char *interface)
#
# Returns a string spaced with possible user set
# configuration variables
pump_get_vars() {
	echo "pump_${1}"
}

# char* pump_local_vars(void)
#
# Returns a string  containing a command to localise vars
pump_local_vars() {
	echo "local pump_IFACE"
}

# bool pump_setup_vars(char* iface)
#
# Configures pump setup information for the interface
# and checks to see if the pumpcd program is installed
pump_setup_vars() {
	eval pump_IFACE=\"\$\{pump_${1}\}\"
}

# bool pump_stop(char *iface)
#
# Stop pump on an interface by calling pumpcd -z $iface
#
# Returns 0 (true) when a dhcp address dropped
# otherwise return 1
pump_stop() {
	local iface=${1} count e
	
	pump_check_installed || return 1

	# We check for a pump process first as querying for status
	# causes pump to spawn a process
	e=$( ps -C pump | grep pump )
	[[ -z ${e} ]] && return 1

	e=$( pump --status -i ${iface} 2>${devnull} | grep ${iface})
	[[ -z ${e} ]] && return 1
	
	einfo "  Releasing DHCP lease for ${iface}"
	for ((count = 0; count < 9; count = count + 1)); do
		e=$( pump --release -i ${iface} 2>${devnull} )
		[[ -z ${e} ]] && break
		sleep 1
	done
	[[ ${count} -lt 9 ]]
	eend $? "Timed out"

	return 0  # we did *attempt* to stop pump
}

# bool pump_start(char *iface)
#
# Start pump on an interface by calling pumpcd $iface $options
#
# Returns 0 (true) when a dhcp address is obtained, otherwise
# the return value from pump
pump_start() {
	local iface=${1}
	local status=$( interface_get_status ${iface} ) check=$( get_device ${iface} )

	# Check that iface was not brought up by the kernel ...
	if [[ ${status} == up && ${check} == ${iface} ]]; then
		einfo "    Keeping kernel configuration for ${iface}"
		return 0
	fi

	# Bring up DHCP for this interface (or alias)
	pump -i ${iface} ${pump_IFACE} 2>${devnull}
	eend $?
	[[ 0 != $? ]] && return $?

	# pump succeeded, show address retrieved
	local addr=$( interface_get_address ${iface} )
	einfo "    ${iface} received address ${addr}"

	return 0
}
