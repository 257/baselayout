#!/bin/bash
# Copyright (c) 2004-2005 Gentoo Foundation
# Distributed under the terms of the GNU General Public License v2
# $Header$

# Contributed by Roy Marples (uberlord@gentoo.org)

action="$1"

. /etc/conf.d/net
[[ -z ${MODULES_DIR} ]] && MODULES_DIR="/lib/rcscripts/net.modules.d"
. "${MODULES_DIR}/system"
. "${MODULES_DIR}/helpers.d/functions"

# Guess which interface module to load - we prefer iproute2
if [[ -x /sbin/ip ]]; then
	interface_module="iproute2"
elif [[ -x /sbin/ifconfig ]]; then
	interface_module="ifconfig"
else
	echo "Can't find a known interface module" >&2
	exit 1
fi

# iwconfig is the best bet for wireless - we use wpa_supplicant
# only if we need to
if [[ -x /usr/sbin/iwconfig ]]; then
	wireless_module="iwconfig"
elif [[ -x /usr/sbin/wpa_supplicant && -S "/var/run/wpa_supplicant/${interface}" ]]; then
	wireless_module="wpa_supplicant"
fi

# Load our modules
. "${MODULES_DIR}/${interface_module}"
function_wrap "${interface_module}" interface
if [[ -n ${wireless_module} ]]; then
	. "${MODULES_DIR}/${wireless_module}"
	function_wrap "${wireless_module}" wireless
fi

auto_interface=${auto_interface:-"yes"}

# Bring the interface up
interface_is_up "${interface}" || interface_up "${interface}"

case "${action}" in
	"bound"|"renew")
		# We handle these actions below
		;;
	"deconfig")
		interface_del_addresses "${interface}"
		mark_service_inactive "net.${interface}"
		if [[ ${auto_interface} == "yes" ]]; then
			remove_state "${interface}"
			best_interface=$( select_best_interface )
			apply_state "${best_interface}"
		fi
		echo "${action}"
		exit 0
		;;
	"nak")
		echo "${action}"
		exit 0
		;;
	"leasefail")
		mark_service_inactive "net.${interface}"
		echo "${action}"
		exit 0
		;;
	*)
		echo "${action}"
		echo "We don't handle that action" >&2
		exit 1
		;;
esac

# Map wireless ESSID variables to interface variables
if wireless_check_extensions "${interface}" ; then
        MODULES=( "${interface_module}" "essidnet" "system" )
        source ${MODULES_DIR}/essidnet
        essidnet_pre_start ${interface}
fi

# Calculate the metric for our routes
ifvar=$( bash_variable ${interface} )
eval metric=\"\$\{metric_${ifvar}\}\"
if [[ -z ${metric} ]]; then
	if [[ ${auto_interface} == "yes" ]]; then
		metric=$( calculate_metric ${interface} )
	else
		metric=0
	fi
	eval metric_${ifvar}="${metric}"
fi

# Configure our IP address
ip=${ip// }
subnet=${subnet// }
cidr=$( netmask2cidr ${subnet} )
broadcast=${broadcast// }
[[ -n ${broadcast} ]] && broadcast="broadcast ${broadcast}"

# If we don't have our address then we flush it and then add our new one
curip=$( interface_get_address ${interface} )
if [[ ${curip} != "${ip}/${cidr}" ]] ; then
	interface_del_addresses ${interface}
	interface_add_address ${interface} "${ip}/${cidr}" ${broadcast}
fi

# Store the address in a cache for future usage
echo ${ip} > /var/cache/dhcp-${interface}.lease
chmod 600 /var/cache/dhcp-${interface}.lease

# Configure our default route - we only have 1 default route
for r in ${router}; do
	interface_default_route ${interface} ${r} ${metric:-0} && break
done

# Configure our hostname - but only if we need it
if [[ -n ${hostname} ]]; then
	x=$( /bin/hostname )
	[[ ${x} == "(none)" || ${x} == "localhost" ]] && /bin/hostname "${hostname}"
fi

# Only setup the information we're told to
# By default that's everything
eval dhcp=\" \$\{dhcp_${ifvar}\} \"
[[ ${dhcp} != *' nodns '* ]] && system_dns "${interface}"
[[ ${dhcp} != *' nontp '* ]] && system_ntp "${interface}"
[[ ${dhcp} != *' nonis '* ]] && system_nis "${interface}"

if [[ ${auto_interface} == "yes" ]]; then
	save_state ${interface}
	best_interface=$( select_best_interface )
	apply_state ${best_interface}
fi

mark_service_started net.${interface}

echo "${action}"
exit 0
