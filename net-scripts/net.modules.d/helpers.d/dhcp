#!/bin/bash
# Copyright (c) 2004-2006 Gentoo Foundation
# Distributed under the terms of the GNU General Public License v2

# Contributed by Roy Marples (uberlord@gentoo.org)

action="$1"
service="net.${interface}"

. /sbin/functions.sh
. "${svclib}/net.modules.d/helpers.d/module-loader"

# Bring the interface up
interface_is_up "${interface}" || interface_up "${interface}"

case "${action}" in
	bound|renew)
		# We handle these actions below
		;;
	deconfig|leasefail)
		# Just remove IPv4 / inet addresses
		interface_del_addresses "${interface}" true
		service_started "${service}" && mark_service_inactive "${service}"
		remove_state "${interface}"
		if [[ ${RC_AUTO_INTERFACE} == "yes" ]] ; then
			best_interface="$(select_best_interface)"
			apply_state "${best_interface}"
		fi
		echo "${action}"
		exit 0
		;;
	nak)
		echo "${action}"
		exit 0
		;;
	*)
		echo "${action}"
		echo "We don't handle that action" >&2
		exit 1
		;;
esac

# Map MAC address variables to interface variables
macnet_pre_start "${interface}" 1>/dev/null

# Map wireless ESSID variables to interface variables
if [[ -n ${wireless_module} ]] ; then
	if wireless_exists "${interface}" ; then
		essidnet_pre_start "${interface}" 1>/dev/null
	fi
fi

# Calculate the metric for our routes
ifvar="$(bash_variable "${interface}")"
metric="metric_${ifvar}"
metric="${!metric}"
if [[ -z ${metric} ]] ; then
	if [[ ${RC_AUTO_INTERFACE} == "yes" ]] ; then
		metric="$(calculate_metric "${interface}")"
	else
		metric="0"
	fi
	eval metric_${ifvar}="${metric}"
fi

# Configure our IP address
ip="${ip// /}"
subnet="${subnet// /}"
cidr="$(netmask2cidr "${subnet}")"
broadcast="${broadcast// /}"
[[ -n ${broadcast} ]] && broadcast="broadcast ${broadcast}"

# If we don't have our address then we flush it and then add our new one
curip="$(interface_get_address "${interface}")"
if [[ ${curip} != "${ip}/${cidr}" ]] ; then
	# Just remove IPv4 / inet addresses
	interface_del_addresses "${interface}" true
	interface_add_address "${interface}" "${ip}/${cidr}" "${broadcast}"
fi

d="dhcp_${ifvar}"
d=" ${!d} "
[[ ${d} == "  " ]] && d=" ${dhcp} "

# Configure our default route - we only have 1 default route
if [[ ${d} != *" nogateway "* ]] ; then
	for r in ${routers}; do
		interface_default_route "${interface}" "${r}" "${metric:-0}" && break
	done
fi

# Configure our hostname - but only if we need it
if [[ -n ${hostname} ]] ; then
	x="$(hostname)"
	[[ ${x} == "(none)" || ${x} == "localhost" ]] && hostname "${hostname}"
fi

[[ ! -d "${statedir}/${interface}" ]] \
	&& mkdir -m 0755 -p "${statedir}/${interface}"

# Only setup the information we're told to
# By default that's everything
[[ ${d} != *" nodns "* ]] && system_dns "${interface}"
[[ ${d} != *" nontp "* ]] && system_ntp "${interface}"
[[ ${d} != *" nonis "* ]] && system_nis "${interface}"

if [[ ${RC_AUTO_INTERFACE} == "yes" ]] ; then
	best_interface="$(select_best_interface)"
	apply_state "${best_interface}"
else
	apply_state "${interface}"
fi

service_inactive "${service}" && mark_service_started "${service}"

echo "${action}"
exit 0

# vim:ts=4
