#!/bin/bash
# Copyright (c) 2004-2005 Gentoo Foundation
# Distributed under the terms of the GNU General Public License v2

# Contributed by Roy Marples (uberlord@gentoo.org)

action="$1"

[[ -z ${MODULES_DIR} ]] && MODULES_DIR="/lib/rcscripts/net.modules.d"
. "${MODULES_DIR}/system"
. /lib/rcscripts/sh/rc-services.sh
. "${MODULES_DIR}/helpers.d/functions"
conf=$(add_suffix "/etc/conf.d/net")
[[ -e ${conf} ]] && source "${conf}"

# Guess which interface module to load - we prefer iproute2
if [[ -x /sbin/ip ]]; then
    interface_module="iproute2"
elif [[ -x /sbin/ifconfig ]]; then
    interface_module="ifconfig"
else
    echo "Can't find a known interface module" >&2
    exit 1
fi

# iwconfig is the best bet for wireless - we use wpa_supplicant
# only if we need to
if [[ -x /usr/sbin/iwconfig ]]; then
    wireless_module="iwconfig"
elif [[ -x /usr/sbin/wpa_supplicant \
    && -S "/var/run/wpa_supplicant/${interface}" ]]; then
    wireless_module="wpa_supplicant"
fi

# Load our modules
. "${MODULES_DIR}/${interface_module}"
function_wrap "${interface_module}" interface
if [[ -n ${wireless_module} ]]; then
    . "${MODULES_DIR}/${wireless_module}"
    function_wrap "${wireless_module}" wireless
fi

# Bring the interface up
interface_is_up "${interface}" || interface_up "${interface}"

case "${action}" in
    "bound"|"renew")
        # We handle these actions below
    ;;
    "deconfig")
        interface_del_addresses "${interface}"
	mark_service_inactive "net.${interface}"
	remove_state "${interface}"
        if [[ ${RC_AUTO_INTERFACE} == "yes" ]]; then
	    best_interface=$( select_best_interface )
	    apply_state "${best_interface}"
	fi
	echo "${action}"
	exit 0
    ;;
    "nak")
	echo "${action}"
	exit 0
    ;;
    "leasefail")
    mark_service_inactive "net.${interface}"
	echo "${action}"
	exit 0
    ;;
    *)
	echo "${action}"
	echo "We don't handle that action" >&2
	exit 1
    ;;
esac

MODULES=( "system" )

# Map MAC address variables to interface variables
. "${MODULES_DIR}/macnet"
macnet_pre_start "${interface}"

# Map wireless ESSID variables to interface variables
if [[ $( type -t wireless_check_extensions ) == "function" ]]; then
    if wireless_check_extensions "${interface}" ; then
	. "${MODULES_DIR}/essidnet"
	essidnet_pre_start "${interface}"
    fi
fi

# Calculate the metric for our routes
ifvar=$( bash_variable "${interface}" )
eval metric=\"\$\{metric_${ifvar}\}\"
if [[ -z ${metric} ]]; then
    if [[ ${RC_AUTO_INTERFACE} == "yes" ]]; then
	metric=$( calculate_metric "${interface}" )
    else
	metric=0
    fi
    eval metric_${ifvar}="${metric}"
fi

# Configure our IP address
ip="${ip// }"
subnet="${subnet// }"
cidr=$( netmask2cidr "${subnet}" )
broadcast="${broadcast// }"
[[ -n ${broadcast} ]] && broadcast="broadcast ${broadcast}"

# If we don't have our address then we flush it and then add our new one
curip=$( interface_get_address "${interface}" )
if [[ ${curip} != "${ip}/${cidr}" ]] ; then
    interface_del_addresses "${interface}"
    interface_add_address "${interface}" "${ip}/${cidr}" "${broadcast}"
fi

# Store the address in a cache for future usage
echo "${ip}" > "/var/cache/dhcp-${interface}.lease"
chmod 600 "/var/cache/dhcp-${interface}.lease"

# Configure our default route - we only have 1 default route
for r in ${router}; do
    interface_default_route "${interface}" "${r}" "${metric:-0}" && break
done

# Configure our hostname - but only if we need it
if [[ -n ${hostname} ]]; then
    x=$( /bin/hostname )
    [[ ${x} == "(none)" || ${x} == "localhost" ]] && /bin/hostname "${hostname}"
fi

[[ ! -d "${statedir}/${interface}" ]] && mkdir -p "${statedir}/${interface}"

# Only setup the information we're told to
# By default that's everything
eval dhcp=\" \$\{dhcp_${ifvar}\} \"
[[ ${dhcp} != *' nodns '* ]] && system_dns "${interface}"
[[ ${dhcp} != *' nontp '* ]] && system_ntp "${interface}"
[[ ${dhcp} != *' nonis '* ]] && system_nis "${interface}"

if [[ ${RC_AUTO_INTERFACE} == "yes" ]]; then
    best_interface=$( select_best_interface )
    apply_state "${best_interface}"
else
    apply_state "${interface}"
fi

mark_service_started "net.${interface}"

echo "${action}"
exit 0
