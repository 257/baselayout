#!/sbin/runscript
# net-scripts main code
# Version 1.0.5
# Copyright (c) 2004 Gentoo Foundation
# Distributed under the terms of the GNU General Public License V2
# Contributed by Roy Marples (uberlord@gentoo.org)
# Many thanks to Aron Griffis (agriffis@gentoo.org)
# for help, ideas and patches

#NB: Config is in /etc/conf.d/net

if [[ -n $NET_DEBUG ]]; then
	set -x
	devnull=/dev/stderr
else
	devnull=/dev/null
fi

# For pcmcia users. note that pcmcia must be added to the same
# runlevel as the net.* script that needs it.
depend() {
	use coldplug hotplug pcmcia usb isdn4linux wlan
}

# Make some wrappers to fudge after/before/need/use depend flags.
# These are callbacks so mods[i] will be set.
after() {
	local x="$*"
	[[ $# -gt 1 ]] && x=$( echo -e "${x// /\n}" | sort | xargs )
	eval "${MODULE}_after() { echo \"$x\"; }"
}
before() {
	local x="$*"
	[[ $# -gt 1 ]] && x=$( echo -e "${x// /\n}" | sort | xargs )
	eval "${MODULE}_before() { echo \"$x\"; }"
}
need() {
	local x="$*"
	[[ $# -gt 1 ]] && x=$( echo -e "${x// /\n}" | sort | xargs )
	eval "${MODULE}_need() { echo \"$x\"; }"
}
use() {
	local x="$*"
	[[ $# -gt 1 ]] && x=$( echo -e "${x// /\n}" | sort | xargs )
	eval "${MODULE}_use() { echo \"$x\"; }"
}

sort() {
	LC_ALL=C /bin/sort "$@"
}

# bool net_start(char *iface)
#
# Starts a net.${iface} if required
# This is used by bridge and bond modules as the interfaces
# they need may have to be created
net_start() {
	local iface=${1}

	interface_exists ${iface} && return 0
	[[ -f ${svcdir}/started/net.${iface} ]] && return 0
	if [[ ! -x /etc/init.d/net.${iface} ]]; then
		eerror "/etc/init.d/net.${iface} does not exist"
		eerror "Cannot start ${iface}"
		return 1
	fi
	/etc/init.d/net.${iface} start
	return $?
}

# void module_class_wrap(char *module, char *provides)
# Setup class wrappers: interface_up -> iproute2_up, for example
module_class_wrap() {
	local module=${1} provides=${2} x 

	# Don't wrap functions if another module already has
	[[ $( type -t ${provides}_provides ) == function ]] && return

	for x in $( typeset -f | grep -o ^${module}_'[^ ]*' ); do
		eval "${provides}${x#${module}}() { ${x} \"\$@\"; }"
	done
}

# bool module_load_minimum(char *module)
#
# Does the minimum checking on a module - even when forcing
module_load_minimum() {
	local f=${1} MODULE=${1##*/}

	if [[ ! -f ${f} ]]; then
		eerror "${f} does not exist"
		return 1
	fi

	if ! source ${f} ; then
		eerror "${MODULE} failed a sanity check"
		return 1
	fi

	for f in check_installed provides check_depends depend; do
		[[ $( type -t ${MODULE}_${f} ) == function ]] && continue
		eerror "${MODULE} does not support the required function ${f}"
		return 1
	done

	# Wrap our before/after/need/use functions
	${MODULE}_depend

	return 0
}

# bool modules_load_auto()
#
# Load and check each module for sanity
# If the module is not installed, the functions are to be removed
modules_load_auto() {
	local e f i j before after beforefuncs diffs unload

	# Populate the MODULES array
	MODULES=( $( find /lib/rcscripts/net.modules.d/ -maxdepth 1 -type f | sort ) )

	# Each of these sources into the global namespace, so it's
	# important that module functions and variables are prefixed with
	# the module name, for example iproute2_

	${checkmodify} && before=$( typeset -f )
	j=${#MODULES[@]}
	loaded_interface=false
	for (( i=0; i<j; i++ )); do
		beforefuncs="$( typeset -F )"

		unload=false
		module_load_minimum ${MODULES[i]} || unload=true
		MODULES[i]=${MODULES[i]##*/}
		! ${unload} && ${MODULES[i]}_check_installed || unload=true

		if [[ ${MODULES[i]} == interface ]]; then
			eerror "interface is a reserved name - cannot load a module called interface"
			unload=true
		fi

		if ${unload}; then		
			unset MODULES[i]
			unset $( diff -U0 -p <( echo "${beforefuncs}" ) <( echo "$( typeset -F )" ) 2>/dev/null \
				| awk 'BEGIN { ORS = " "; } /+declare -f/ { print $3; }' ) 2>/dev/null
			before="$( typeset -f )"
			continue
		fi
		
		# Double check that we've only *added* to the function list, not
		# replaced.  This is as much protection for devs as for users ;-)
		after="$( typeset -f )"

		# Though diffutils is in the profiles, don't depend that it will exist.
		# Here is an example of the output we're looking through.
		# 
		# $ diff -U0 -p <(echo "$funcs") <(echo "$funcs2")
		# --- /dev/fd/63  2004-10-12 17:51:10.342906704 -0400
		# +++ /dev/fd/62  2004-10-12 17:51:10.346905655 -0400
		# @@ -69,0 +70,4 @@ addpath () 
		# +asdf () 
		# +{ 
		# +    echo
		# +}
		# @@ -1160,4 +1163,0 @@ xvf () 
		# -xzf () 
		# -{ 
		# -    xf "$@"
		# -}
		# @@ -1166 +1166,2 @@ xzvf () 
		# -    xvf "$@"
		# +    xvf "$@";
		# +    echo whoah
		#
		diffs=$( diff -U0 -p <( echo "${before}" ) <( echo "${after}" ) 2>/dev/null | \
			awk 'BEGIN { ORS = " "; }						# no need for xargs
				 /^@@ / { f = $(NF-1); }					# collect function names reported by diff
				 /^-/ && $2 == "()" { f = substr($1, 2); }	# override when functions are removed
				 /^+/ && $2 == "()" { f = ""; }				# ignore when functions are added
				 /^-/ && f { print f; f = ""; }				# report only once per function
				 ' )
		if [[ -n ${diffs} ]]; then
			eerror "${MODULES[i]} modified functions: ${diffs}"
			return 1
		fi
		before="${after}"
	done
	MODULES=( "${MODULES[@]}" )

	return 0
}


# bool modules_check_use(void)
#
# Ensure that all modules have the required modules loaded
# This enables us to remove modules from the MODULES array
# Whilst other modules can still explicitly call them
# One example of this is essidnet which configures network
# settings for the specific ESSID connected to as the user
# may be using a daemon to configure wireless instead of our
# iwconfig module
modules_check_use() {
	local i j missingdeps nmods=${#MODULES[@]}

	for (( i=0; i<${nmods}; i++ )); do
		[[ $( type -t ${MODULES[i]}_use ) != function ]] && continue
		for j in $( ${MODULES[i]}_use ); do
			missingdeps=true
			for (( k=0; k<${nmods}; k++ )); do
				[[ -z ${MODULES[k]} ]] && continue
				[[ ${j} != ${MODULES[k]} && ${j} != ${PROVIDES[k]} ]] && continue
				missingdeps=false
				break
			done
			${missingdeps} && unset MODULES[i] && unset PROVIDES[i]
		done
	done

	MODULES=( "${MODULES[@]}" )
	PROVIDES=( "${PROVIDES[@]}" )
}

# bool modules_check_user(void)
modules_check_user() {
	local -a umods
	local i j k l npref nmods=${#MODULES[@]}

	# Has the interface got any specific modules?
	eval umods=( \"\$\{modules_${iface}\[@\]\}\" )

	# Global setting follows interface-specific setting
	umods=( "${umods[@]}" "${modules[@]}" )

	# Add our preferred modules
	npref=3
	umods=( "${umods[@]}" "ifconfig" "dhcpcd" "iwconfig" )

	# First we strip any modules that conflict from user settings
	# So if the user specifies pump then we don't use dhcpcd
	for (( i=0; i<${#umods[@]}; i++ )); do
		# Some users will inevitably put "dhcp" in their modules
		# list.  To keep users from screwing up their system this
		# way, ignore this setting so that the default dhcp
		# module will be used.
		[[ ${umods[i]} == dhcp ]] && continue

		# We remove any modules we explicitly don't want
		if [[ ${umods[i]} == !* ]]; then
			for (( j=0; j<${nmods}; j++ )); do
				[[ -z ${MODULES[j]} ]] && continue
				if [[ ${umods[i]:1} == ${MODULES[j]} || ${umods[i]:1} == ${modprovides[j]} ]]; then
					# We may need to setup a class wrapper for it even though
					# we don't use it directly
					${MODULES[j]}_check_installed && module_class_wrap ${MODULES[j]}
					unset MODULES[j]
					unset PROVIDES[j]
					break
				fi
			done
			continue
		fi

		if [[ $( type -t ${umods[i]}_provides ) != function ]]; then
			# If the module is one of our preferred modules, then
			# ignore this error; whatever is available will be
			# used instead.
			(( i < ${#umods[@]} - npref )) || continue
			eerror "${umods[i]} is not a valid module (missing provides)"
			return 1
		fi

		# Ensure that the user specified module has its package installed
		if (( i < ${#umods[@]} - npref )); then
			# $1==true causes check_installed to report its own errors
			${umods[i]}_check_installed true || return 1
		else
			# If this happens on a preferred modules, ignore it;
			# whatever is available will be used instead.
			${umods[i]}_check_installed false || continue
		fi

		mod=$( ${umods[i]}_provides )
		for (( j=0; j<${nmods}; j++ )); do
			[[ -z ${MODULES[j]} ]] && continue
			if [[ ${PROVIDES[j]} == ${mod} && ${umods[i]} != ${MODULES[j]} ]]; then
				# We don't have a match - now ensure that we still provide an alternative.
				# This is to handle our preferred modules.
				for (( l=0; l<${nmods}; l++ )); do
					[[ ${l} -eq ${j} || -z ${MODULES[l]} ]] && continue
					if [[ ${PROVIDES[l]} == ${mod} ]]; then
						unset MODULES[j]
						unset PROVIDES[j]
						break
					fi
				done
			fi
		done
	done

	# Then we strip conflicting modules.
	# We only need to do this for 3rd party modules that conflict with
	# our own modules and the preferred list AND the user modules
	# list doesn't specify a preference.
	for (( i=0; i<${nmods}-1; i++ )); do
		[[ -z ${MODULES[i]} ]] && continue			
		for (( j=i+1; j<${nmods}; j++)); do
			[[ -z ${MODULES[j]} ]] && continue
			[[ ${PROVIDES[i]} == ${modprovides[j]} ]] && unset MODULES[j] && unset PROVIDES[j]
		done
	done

	MODULES=( "${MODULES[@]}" )
	PROVIDES=( "${PROVIDES[@]}" )
	return 0
}

# void modules_sort(void)

modules_sort() {
	local -a modnums sort_history modafter modbefore
	local i j k p changed_something

	# Sort our modules
	# We do this by assigning numbers to each module
	# We also assign modbefore and modafter so we don't
	# shell out as much because it's expensive on CPU.
	modnums=()
	for (( i=0; i<${#MODULES[@]}; i++ )); do
		modnums[i]=${i}
		[[ $( type -t ${MODULES[i]}_after ) == function ]] && modafter[i]=$( ${MODULES[i]}_after )
		[[ $( type -t ${MODULES[i]}_before ) == function ]] && modbefore[i]=$( ${MODULES[i]}_before )
	done
	
	# Then we swap numbers based on and after/before flags
	# until we don't swap anymore. The sort_history array prevents
	# the possibility of an infinite loop
	sort_history[0]="${modnums[*]}"
	for (( k=1; 1; k++ )); do
		changed_something=false
		for (( i=0; i<${#MODULES[@]}; i++ )); do
			for p in ${modafter[i]}; do
				for (( j=0; j<${#MODULES[@]}; j++ )); do
					[[ ${p} != ${MODULES[j]} && ${p} != ${PROVIDES[j]} ]] && continue
					if [[ ${modnums[i]} -lt ${modnums[j]} ]]; then
						tmp=${modnums[i]}
						modnums[i]=${modnums[j]}
						modnums[j]=${tmp}
						changed_something=true
					fi
				done
			done
			for p in ${modbefore[i]}; do
				for (( j=0; j<${#MODULES[@]}; j++ )); do
					[[ ${p} != ${MODULES[j]} && ${p} != ${PROVIDES[j]} ]] && continue
					if [[ ${modnums[i]} -gt ${modnums[j]} ]]; then
						tmp=${modnums[i]}
						modnums[i]=${modnums[j]}
						modnums[j]=${tmp}
						changed_something=true
					fi
				done
			done
		done
		${changed_something} || break

		# Make sure we aren't repeating a previous state
		# First time through, k=1, k/2=0
		sort_history[k]="${modnums[*]}"
		if [[ ${sort_history[k]} == ${sort_history[k/2]} ]]; then
			eerror "Detected an infinite loop sorting modules; blundering ahead"
			break
		fi
	done

	# Finally we sort our modules in number order
	um=""
	for (( i=0; i < ${#MODULES[@]}; i++ )); do
		um="${um}${modnums[i]} ${MODULES[i]} ${PROVIDES[i]}\n"
	done

	p=( $( echo -e "${um}" | sort -n | awk '{print $2,$3}' ) )
	MODULES=()
	PROVIDES=()
	j=0
	for ((i=0; i < ${#p[@]}; i=i+2 )); do
		MODULES[j]=${p[i]}
		PROVIDES[j]=${p[i+1]}
		(( j++ ))
	done
}

# bool modules_check_depends(bool showprovides)
modules_check_depends() {
	local showprovides=${1:-false} nmods=${#MODULES[@]} i j needmod
	local missingdeps p  interface=false

	for (( i=0; i<${nmods}; i++ )); do
		if [[ $( type -t ${MODULES[i]}_need ) == function ]]; then
			for needmod in $( ${MODULES[i]}_need ); do
				missingdeps=true
				for (( j=0; j<${nmods}; j++ )); do
					if [[ ${needmod} == ${MODULES[j]} || ${needmod} == ${PROVIDES[j]} ]]; then
						missingdeps=false
						break
					fi
				done
				if ${missingdeps} ; then
					eerror "${MODULES[i]} needs ${needmod} (dependency failure)"
					return 1
				fi
			done
		fi

		${MODULES[i]}_check_depends || return 1
		[[ ${PROVIDES[i]} == interface ]] && interface=true

		if ${showprovides} ; then
			[[ ${PROVIDES[i]} != ${MODULES[i]} ]] && veinfo "${MODULES[i]} provides ${PROVIDES[i]}"
		fi
	done

	if ! ${interface} ; then
		eerror "no interface module has been loaded"
		return 1
	fi

	return 0
}

# bool modules_load(char *iface, bool starting)
#
# Loads the defined handler and modules for the interface
# Returns 0 on success, otherwise 1
modules_load()  {
	local iface=${1} starting=${2:-true} mod p=false i j
	local -a x
	local RC_INDENTATION=${RC_INDENTATION}	# so it will reset after function
	local -a PROVIDES

	if [[ ${iface} == lo ]]; then
		# We force lo to only use these modules for a major speed boost
		modules_force=( "ifconfig" "iproute2" )
	else
		eval x=( \"\$\{modules_force_${iface}\[@\]\}\" )
		[[ -n ${x} ]] && modules_force=( "${x[@]}" )
		if [[ -n ${modules_force} ]]; then
			ewarn "WARNING: You are forcing modules!"
			ewarn "Do not complain or file bugs if things start breaking"
			report=true
		fi
		veinfo "Loading networking modules for ${iface}"
	fi
	eindent

	if [[ -z ${modules_force} ]]; then
		modules_load_auto || return 1
	else
		j=${#modules_force[@]}
		for (( i=0; i<j; i++ )); do
			module_load_minimum "/lib/rcscripts/net.modules.d/${modules_force[i]}" || return 1
			${modules_force[i]}_check_installed || unset modules_force[i]
		done
		MODULES=( "${modules_force[@]}" )
	fi

	# We now buffer the _provides functions for a big speed boost
	j=${#MODULES[@]}
	for (( i=0; i<j; i++ )); do
		PROVIDES[i]=$( ${MODULES[i]}_provides )
	done

	if [[ -z ${modules_force[@]} ]]; then
		modules_check_use || return 1
		if ${starting}; then
			modules_check_user || return 1
		fi
		modules_sort
	fi

	[[ ${iface} != lo ]] && veinfo "modules: ${MODULES[@]}"
	eindent

	# Setup class wrappers: interface_up -> iproute2_up, for example
	j=${#MODULES[@]}
	for (( i=0; i<j; i++ )); do
		module_class_wrap ${MODULES[i]} ${PROVIDES[i]}
	done

	[[ ${iface} != lo && ${starting} == true ]] && p=true
	modules_check_depends ${p} || return 1
	return 0
}

# char* interface_device(char *iface)
#
# Gets the base device of the interface
# Can handle eth0:1 and eth0.1
# Which returns eth0 in this case
interface_device() {
	local iface=${1}
	local dev=${iface%%.*}
	[[ ${dev} == ${iface} ]] && dev=${iface%%:*}
	echo ${dev}
}

# char* interface_type(char* iface)
#
# Returns the base type of the interface
# eth, ippp, etc
interface_type() {
	echo ${1%%[0-9]*}
}

# char* interface_variable(char *iface)
#
# Returns a bash variable name based on the interface
interface_variable() {
	local n=${1//:/_}
	echo ${n//./_}
}

# bool iface_start(char *interface)
#
# iface_start is called from start.  It's expected to start the base
# interface (for example "eth0"), aliases (for example "eth0:1") and to start
# VLAN interfaces (for example eth0.0, eth0.1).  VLAN setup is accomplished by
# calling itself recursively.
iface_start() {
	local iface=${1} mod i label label_counter=-1 x conf warn=false inet6
	local RC_INDENTATION=${RC_INDENTATION}	# so it will reset after function

	# Localise and initialise variables
	for mod in ${MODULES[@]}; do
		x="${mod}_local_vars"
		if [[ $( type -t ${x} ) == function ]]; then
			x=$( ${x} )
			${x}
		fi
		x="${mod}_setup_vars"
		if [[ $( type -t ${x} ) == function ]]; then
			${x} ${iface} || return 1
		fi
	done

	# Provide a default of DHCP if no configuration is set
	if [[ -z ${config_IFACE} ]]; then
		if [[ $( type -t dhcp_start ) == function ]]; then
			config_IFACE=( "dhcp" )
			warn=true
		else
			eerror "Cannot default to dhcp as there is no dhcp module loaded"
			eerror "No configuration for ${iface}"
			return 1
		fi
	fi

	einfo "Bringing up ${iface}"
	eindent
	for (( label_counter=0; label_counter < ${#config_IFACE[@]}; label_counter++ )); do
		# Set a label for the alias if $label_counter > 0
		[[ ${label_counter} -eq 0 ]] && label=${iface} || label=${iface}:${label_counter}

		# Null inet address
		# We do this so we can have an inet6 only setup
		[[ ${config_IFACE[label_counter]} == "null" ]] && eend 0 && continue

		${warn} && ewarn "Configuration not set for ${iface} - assuming dhcp"
		warn=false

		# We convert it to an array - this has the added
		# bonus of trimming spaces!
		conf=( ${config_IFACE[label_counter]} )
		einfo "${label} ${conf[0]}"

		# Do we have a function for our config?
		if [[ $( type -t ${conf[0]}_start ) == function ]]; then
			# Check that the module is valid
			x=false
			for mod in ${MODULES[@]}; do
				if [[ $( ${mod}_provides ) == ${conf[0]} ]]; then
					x=true
					break
				fi
			done

			if ! ${x}; then
				[[ $( type -t ${conf[0]}_check_intalled == function ) ]] && ${conf[0]}_check_installed true
				eerror "No loaded modules provide \"${conf[0]}\" (${conf[0]}_start)"
			else
				eindent
				${conf[0]}_start ${label} ; x=$?
				eoutdent
				[[ ${x} == 0 ]] && continue
			fi
		# We need to test to see if it's an IP address or a function
		# We do this by testing if the 1st character is a digit
		elif [[ ${conf[0]:0:1} == [[:digit:]] ]]; then
			eindent
			x=0
			if [[ $(type -t address_exists ) == function ]]; then
				if address_exists ${label} ${conf[0]} ; then
					eerror "${conf[0]} already taken on ${label}"
					x=1
				fi
			fi
			[[ ${x} == 0 ]] && interface_configure ${label} ${conf[@]} ; x=$?
			[[ ${x} == 0 ]] && continue
			eoutdent
		else
			eerror "No loaded modules provide \"${conf[0]}\" (${conf[0]}_start)"
		fi

		if [[ -n ${config_fallback_IFACE[label_counter]} ]]; then
			einfo "Trying fallback configuration"
			config_IFACE[label_counter]=${config_fallback_IFACE[label_counter]}
			config_fallback_IFACE[label_counter]=''
			(( label_counter-- )) # since the loop will increment it
			continue
		fi

		# Only return failure if it was the first address for the interface
		[[ ${label_counter} -eq 0 ]] && return 1
	done
	eoutdent

	# Enabling rp_filter causes wacky packets to be auto-dropped by
	# the kernel.  Note that we only do this if it is not set via
	# /etc/sysctl.conf ...
	if [[ -e /proc/sys/net/ipv4/conf/${iface}/rp_filter && \
			-z "$(grep -s '^[^#]*rp_filter' /etc/sysctl.conf)" ]]; then
		echo -n 1 > /proc/sys/net/ipv4/conf/${iface}/rp_filter
	fi

	# Start any modules with _post_start
	# We do this here as the variables were localised in this function
	for mod in ${MODULES[@]}; do
		if [[ function == $( type -t ${mod}_post_start ) ]]; then
			${mod}_post_start ${iface} || return 1
		fi
	done

	return 0
}

# bool iface_stop(char *interface)
#
# iface_stop: bring down an interface.  Don't trust information in
# /etc/conf.d/net since the configuration might have changed since
# iface_start ran.  Instead query for current configuration and bring
# down the interface.
#
# However, we are currently reliant on handler and modules specified
# in /etc/conf.d/net
iface_stop() {
	local iface=${1} i aliases need_begin=false mod
	local RC_INDENTATION=${RC_INDENTATION}	# so it will reset after function

	einfo "Bringing down ${iface}"
	eindent

	# Collect list of aliases for this interface.
	# List will be in reverse order.
	aliases=$( interface_get_aliases_rev ${iface} )

	# Stop aliases before primary interface.
	# Note this must be done in reverse order, since ifconfig eth0:1 
	# will remove eth0:2, etc.  It might be sufficient to simply remove 
	# the base interface but we're being safe here.
	for i in ${aliases} ${iface}; do
		# Stop all our modules
		for mod in ${MODULES[@]}; do
			[[ $( type -t ${mod}_stop ) == function ]] && ${mod}_stop ${i}
		done

		# A module may have removed the interface
		interface_exists ${iface} || { eend 0; continue; }

		# Delete all the addresses for this alias
		interface_del_addresses ${i} true

		# Do final shut down of this alias
		ebegin "Shutting down ${i}"
		interface_iface_stop ${i}
		eend $?
	done

	return 0
}

# bool run_start(char *iface)
#
# Brings up ${IFACE}.  Calls preup, iface_start, then postup.
# Returns 0 (success) unless preup or iface_start returns 1 (failure).
# Ignores the return value from postup.
# We cannot check that the device exists ourselves as modules like
# tuntap make create it.
run_start() {
	local iface=${1} x mod

	if [[ ${iface} == lo ]]; then
		ebegin "Bringing up ${iface}"
		interface_loopback_create
		eend $?
		return $?
	fi

	# We may not have a loaded module for ${iface}
	# Some users may have "alias natsemi eth0" in /etc/modules.d/foo
	# so we can work with this
	# However, if they do the same with eth1 and try to start it
	# but eth0 has not been loaded then the module gets loaded as
	# eth0.
	# Not much we can do about this :(
	! interface_exists ${iface} && /sbin/modprobe ${iface} &>/dev/null

	# Call user-defined preup function if it exists
	if [[ $( type -t preup ) == function ]]; then
		einfo "Running preup function"
		eindent
		preup ${iface} ; x=$?
		eoutdent
		if [[ ${x} != 0 ]]; then
			eerror "preup ${iface} failed"
			return 1
		fi
	fi

	# pre Start any modules with
	for mod in ${MODULES[@]}; do
		if [[ $( type -t ${mod}_pre_start ) == function ]]; then
			${mod}_pre_start ${iface} || { eend 1; return 1; }
		fi
	done

	# Start the interface
	if ! iface_start ${iface} ; then
		interface_down ${iface}
		eend 1
		return 1
	fi

	# post Start modules is called in iface_start
	# as that's where the functions get localised
	# and they may have to call iface_start recursively

	# Call user-defined postup function if it exists
	if [[ $( type -t postup ) == function ]]; then
		einfo "Running postup function"
		eindent
		postup ${iface}
		eoutdent
	fi

	return 0
}

# bool run_stop(char *iface) {
#
# Brings down ${iface}.  If predown call returns non-zero, then
# stop returns non-zero to indicate failure bringing down device.
# In all other cases stop returns 0 to indicate success.
run_stop() {
	local iface=${1} mod x

	# Don't run any special shutdown functions for lo
	if [[ ${iface} == lo ]]; then
		ebegin "Shutting down ${iface}"
		interface_iface_stop ${iface}
		eend $?
		return 0
	fi

	# Call user-defined predown function if it exists
	if [[ $( type -t predown ) == function ]]; then
		einfo "Running predown function"
		eindent
		predown ${iface} ; x=$?
		eoutdent
		if [[ ${x} != 0 ]]; then
			eend 1 "predown ${iface} failed"
			return 1
		fi
	elif is_net_fs /; then
		eerror "root filesystem is network mounted -- can't stop ${iface}"
		return 1
	fi

	# pre Stop any modules
	for mod in ${MODULES[@]}; do
		[[ $( type -t ${mod}_pre_stop ) == function ]] && ${mod}_pre_stop ${iface}
	done

	iface_stop ${IFACE} || return 1  # always succeeds, btw

	# post Stop any modules
	for mod in ${MODULES[@]}; do
		# We have already taken down the interface, so no need to error
		[[ $( type -t ${mod}_post_stop ) == function ]] && ${mod}_post_stop ${iface}
	done

	# Call user-defined postdown function if it exists
	if [[ $( type -t postdown ) == function ]]; then
		einfo "Running postdown function"
		eindent
		postdown ${iface}
		eoutdent
	fi

	return 0
}

# bool run(char *iface, char *cmd)
#
# Main start/stop entry point
# We load modules here and remove any functions that they
# added as we may be called inside the same shell scope for another interface
run() {
	local iface=${1} cmd=${2} r=1 RC_INDENTATION=${RC_INDENTATION}	# so it will reset after function
	local before="$( typeset -F )" starting=true
	local -a MODULES mods

	eindent

	[[ ${cmd} == "stop" ]] && starting=false
	if modules_load ${IFACE} ${starting} ; then
		if [[ ${cmd} == "stop" ]]; then
			# Reverse the module list for stopping
			mods=( "${MODULES[@]}" )
			for ((i = 0; i < ${#mods[@]}; i++)); do
				MODULES[i]=${mods[((${#mods[@]} - i - 1))]}
			done

			run_stop ${iface} && r=0
		else
			run_start ${iface} && r=0
		fi
	fi

	# We need to remove added functions before we quit as other init
	# scripts may be launching afterwards
	unset $( diff -U0 -p <( echo "${before}" ) <( echo "$( typeset -F )" ) 2>/dev/null \
		| awk 'BEGIN { ORS = " "; } /+declare -f/ { print $3; }' ) 2>/dev/null

	return ${r}
}

# bool start(void)
#
# Start entry point so that we only have one function
# which localises variables and unsets functions
start() {

	einfo "Starting ${IFACE}"
	run ${IFACE} start
	return $?
}

# bool stop(void)
#
# Stop entry point so that we only have one function
# which localises variables and unsets functions
stop() {
	einfo "Stopping ${IFACE}"
	run ${IFACE} stop
	return $?
}

# vim:ts=4
