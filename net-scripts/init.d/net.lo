#!/sbin/runscript
# net-scripts main code
# Version 0.6.2
# Copyright (c) 2004 Gentoo Foundation
# Distributed under the terms of the GNU General Public License V2
# Contributed by Roy "UberLord" Marples (uberlord@rsm.demon.co.uk)

#NB: Config is in /etc/conf.d/net

if [[ -n $NET_DEBUG ]]; then
	set -x
	devnull=/dev/stderr
else
	devnull=/dev/null
fi

# For pcmcia users. note that pcmcia must be added to the same
# runlevel as the net.* script that needs it.
depend() {
	use hotplug pcmcia usb bridge
}

# Make some wrappers to fudge after/before/need/use depend flags
after() {
	eval "${mods[i]}_after() { echo \"$@\"; }"
}
before() {
	eval "${mods[i]}_before() { echo \"$@\"; }"
}
need() {
	eval "${mods[i]}_need() { echo \"$@\"; }"
}
use() {
	eval "${mods[i]}_user() { echo \"$@\"; }"
}

sort() {
	LC_ALL=C /bin/sort "$@"
}

# bool modules_load(char *iface, bool all)
#
# Loads the defined handler and modules for the interface
# Returns 0 on success, otherwise 1
modules_load() {
	local iface=${1} all=${2} i j k p um e before after diffs mod
	local -a mods=( $( find /etc/net.modules.d/ -maxdepth 1 -type f | sort ) ) umods

	all=${all:-false}
	[[ lo != ${iface} ]] && ebegin "Loading networking scripts"

	# Each of these sources into the global namespace, so it's
	# important that module functions and variables are prefixed with
	# the module name, for example iproute2_
	before=$( typeset -f )
	j=${#mods[@]}
	k=false
	for ((i = 0; i < j; i++ )); do
		source ${mods[i]} || {
			eerror "  ${mods[i]##*/} failed a sanity check - will not load"
			unset mods[i]
			continue
		}
		mods[i]=${mods[i]##*/}
		if [[ interface == ${mods[i]} ]]; then
			eerror "  interface is a reserved name - cannot load a module called interface"
			return 1
		fi

		e=false
		for p in check_installed provides check_depends depend; do
			[[ function == $(type -t ${mods[i]}_${p}) ]] && continue
			eerror "  ${mods[i]} does not support the required function ${p}\n"
			e=true
		done
		[[ true == ${e} ]] && return 1

		# Wrap our before/after/need/use functions
		${mods[i]}_depend

		# Double check that we've only *added* to the function list, not
		# replaced.  This is as much protection for devs as for users ;-)
		after=$( typeset -f )

		# Though diffutils is in the profiles, don't depend that it will exist
		# Currently we cannot tell which function got modified as bash can do nested functions .... :/
		diffs=$( diff -up <(echo "${before}") <(echo "${after}") 2>/dev/null | awk '{if ($1 == "-") print "changed"}' | xargs )
		if [[ -n ${diffs} ]]; then
			eerror "  ${mods[i]} modified at least one existing function"
			return 1
		fi
		before="${after}"

		if ! ${mods[i]}_check_installed; then
			unset mods[i]
			continue
		fi

		[[ -n ${mods[i]} && interface == $( ${mods[i]}_provides ) ]] && k=true
	done

	if [[ false == k ]]; then
		eerror "  no interface module has been loaded"
		return 1
	fi

	mods=( "${mods[@]}" )

	if [[ true != ${all} ]]; then
		# Has the interface got any specific modules?
		eval umods=( \"\$\{modules_${iface}\[@\]\}\" )

		# If not then has a global setting been made?
		[[ -z ${umods} ]] && eval umods=( \"\$\{modules\[@\]\}\" )

		# We add our preferred modules here
		umods=( "${umods[@]}" "ifconfig" "dhcpcd" )

		# First we strip any modules that conflict from user settings
		# So if the user specifies pump then we don't use dhcpcd
		for ((i = 0; i < ${#umods[@]}; i++)); do
			if [[ function != $( type -t ${umods[i]}_provides ) ]]; then
				eerror "${umods[i]} is not a valid module (missing provides)"
				return 1
			fi

			#Ensure that the user specified module has it's package installed
			if [[ ${e} -lt ${#umods[@]}-2 ]]; then
				${umods[i]}_check_installed true || return 1
			fi

			k=${#mods[@]}
			for ((j = 0; j < k; j++)); do
				if [[ $( ${mods[j]}_provides ) == $( ${umods[i]}_provides ) && ${umods[i]} != ${mods[j]} ]]; then
					# We don't have a match - now ensure that we still provide an alternative
					# This is to handle our preferred modules
					for ((e=0; e < k; e++)); do
						[[ ${e} -eq ${j} || -z ${mods[e]} ]] && continue
						if [[ $( ${mods[e]}_provides ) == $( ${umods[i]}_provides ) ]]; then
							unset mods[j]
							break
						fi
					done
				fi
			done
			mods=( "${mods[@]}" )
		done
	
		# Then we strip conflicting modules
		# We only need todo this for 3rd party modules that conflict with
		# our own modules and the preferred list AND the user modules
		# list doesn't specify a preferrence
		k=${#mods[@]}
		for ((i = 0; i < k - 1; i++)); do
			[[ -z ${mods[i]} ]] && continue			
			for ((j = i + 1; j < k; j++ )); do
				[[ -z ${mods[j]} ]] && continue
				[[ $( ${mods[i]}_provides ) == $( ${mods[j]}_provides ) ]] && unset mods[j]
			done
		done
		mods=( "${mods[@]}" )
	fi

	# Sort our modules
	# We do this by assigning numbers to each module
	umods=()
	for ((i=0; i < ${#mods[@]}; i++)); do
		umods=( "${umods[@]}" "${i}" )
	done

	# Then we swap numbers based on and after/before flags
	# until we don't swap anymore. Yes, there's the potential for
	# an infinite loop if module developers are clumsy
	while [[ true ]]; do
		um=false
		for ((i=0; i < ${#mods[@]}; i++)); do
			if [[ function == $( type -t ${mods[i]}_after ) ]]; then
				for p in $( ${mods[i]}_after | sort ); do
					for ((j=0; j < ${#mods[@]}; j++)); do
						[[ ${p} != ${mods[j]} && ${p} != $( ${mods[j]}_provides ) ]] && continue
						if [[ ${umods[i]} -lt ${umods[j]} ]]; then
							k=${umods[i]}
							umods[i]=${umods[j]}
							umods[j]=${k}
							um=true
						fi
					done
				done
			fi
			if [[ function == $( type -t ${mods[i]}_before ) ]]; then
				for p in $( ${mods[i]}_before | sort ); do
					for ((j=0; j < ${#mods[@]}; j++)); do
						[[ ${p} != ${mods[j]} && ${p} != $( ${mods[j]}_provides ) ]] && continue
						if [[ ${umods[i]} -gt ${umods[j]} ]]; then
							k=${umods[i]}
							umods[i]=${umods[j]}
							umods[j]=${k}
							um=true;
						fi
					done
				done
			fi
		done
		[[ false == ${um} ]] && break
	done

	# Finally we sort our modules in number order and volia :)
	um=""
	for ((i=0; i < ${#mods[@]}; i++)); do
		um="${um}${umods[i]} ${mods[i]}\n"
	done
	MODULES=( $( echo -e ${um} | sort | awk '{print $2}' ) )

	[[ lo != ${iface} ]] && einfo "  modules: ${MODULES[@]}"

	# Setup class wrappers: interface_up -> iproute2_up, for example
	for i in ${MODULES[@]}; do
		p=$( ${i}_provides )
		[[ ${p} == ${i} ]] && continue;
		for j in $(typeset -f | grep -o ^${i}_'[^ ]*' ); do
			eval "${p}${j#${i}}() { ${j} \"\$@\"; }"
		done
	done

	# Ensure that all modules have what they need
	# from either other modules or the system
	for i in ${MODULES[@]}; do
		if [[ function == $( type -t ${i}_need ) ]]; then
			for m in $( ${i}_need ); do
				um=false
				for j in ${MODULES[@]}; do
					p=$( ${j}_provides )
					if [[ ${m} == ${j} || ${m} == $( ${j}_provides ) ]]; then
						um=true;
						break;
					fi
				done
				if [[ false == ${um} ]]; then
					eerror "${i} needs ${m} (dependency failure)"
					return 1
				fi
			done
		fi
		${i}_check_depends || return 1
		e=$( ${i}_provides )
		if [[ true != ${all} && lo != ${iface} && ${e} != ${i} ]]; then
			einfo "    ${i} provides ${e}"
		fi
	done
}

# char* get_device(char *iface)
#
# Gets the base device of the interface
# Can handle eth0:1 and eth0.1
# Which returns eth0 in this case
get_device() {
	local iface=${1}
	local dev=${iface%%.*}
	[[ ${dev} == ${iface} ]] && dev=${iface%%:*}
	echo ${dev}
}

# bool iface_start(char *interface)
#
# iface_start is called from start.  It's expected to start the base
# interface (for example "eth0"), aliases (for example "eth0:1") and to start
# VLAN interfaces (for example eth0.0, eth0.1).  VLAN setup is accomplished by
# calling itself recursively.
iface_start() {
	local iface=${1} mod i label x conf

	# Localise and initialise variables
	for mod in ${MODULES[@]}; do
		x="${mod}_local_vars"
		if [[ function == $( type -t ${x} ) ]]; then
			x=$( ${x} )
			${x}
		fi
		x="${mod}_setup_vars"
		if [[ function == $( type -t ${x} ) ]]; then
			${x} ${iface} || return 1
		fi
	done

	if [[ -z ${config_IFACE} ]]; then
		eerror "configuration has not been set!"
		return 1
	fi

	ebegin "Bringing ${iface} up"
	for ((i = 0; i < ${#config_IFACE[@]}; i++)); do
		# Set a label for the alias if $i > 0
		[[ ${i} -eq 0 ]] && label=${iface} || label=${iface}:${i}

		# We convert it to an array - this has the added
		# bonus of trimming spaces!
		conf=( ${config_IFACE[i]} )
		einfo "  ${label} ${conf[0]}"
		
		# Do we have a function for our config?
		if [[ function == $( type -t ${conf[0]}_start ) ]]; then
			${conf[0]}_start ${label} && continue
			if [[ -n ${config_fallback_IFACE[i]} ]]; then
				einfo "    Trying fallback configuration"
				config_IFACE[i]=${config_fallback_IFACE[i]}
				config_fallback_IFACE[i]=''
				(( i = i - 1 )) # since the loop will increment it
			else
				# Only return failure if it was the first address for the interface
				[[ ${i} -eq 0 ]] && return 1
				continue
			fi
		fi

		# We need to test to see if it's an IP address or a function
		# We do this by testing if there is only 1 parameter
		if [[ ${#conf[@]} -eq 1 ]]; then
			eerror "No loaded modules provide \"${conf[0]}\" (${conf[0]}_start)"
			# Only return failure if it was the first address for the interface
			[[ ${i} -eq 0 ]] && return 1
			continue
		fi

		interface_configure ${label} ${conf[@]} && continue
		# Only return failure if it was the first address for the interface
		[[ ${i} -eq 0 ]] && return 1
	done

	# Enabling rp_filter causes wacky packets to be auto-dropped by
	# the kernel.  Note that we only do this if it is not set via
	# /etc/sysctl.conf ...
	if [[ -e /proc/sys/net/ipv4/conf/${iface}/rp_filter && \
			-z "$(grep -s '^[^#]*rp_filter' /etc/sysctl.conf)" ]]; then
		echo -n 1 > /proc/sys/net/ipv4/conf/${iface}/rp_filter
	fi

	# Start any modules with _post_start
	# We do this here as the variables were localised in this function
	for mod in ${MODULES[@]}; do
		if [[ function == $( type -t ${mod}_post_start ) ]]; then
			${mod}_post_start ${iface} || return 1
		fi
	done

	return 0
}

# bool iface_stop(char *interface)
#
# iface_stop: bring down an interface.  Don't trust information in
# /etc/conf.d/net since the configuration might have changed since
# iface_start ran.  Instead query for current configuration and bring
# down the interface.
#
# However, we are currently reliant on handler and modules specified
# in /etc/conf.d/net
iface_stop() {
	local iface=${1} i aliases need_begin=false mod

	ebegin "Bringing ${iface} down"

	# Collect list of aliases for this interface.
	# List will be in reverse order.
	aliases=$( interface_get_aliases_rev ${iface} )
	[[ -n ${aliases} ]] && need_begin=true

	# Stop aliases before primary interface.
	# Note this must be done in reverse order, since ifconfig eth0:1 
	# will remove eth0:2, etc.  It might be sufficient to simply remove 
	# the base interface but we're being safe here.
	for i in ${aliases} ${iface}; do
		# Stop all our modules
		for mod in ${MODULES[@]}; do
			[[ function == $( type -t ${mod}_stop ) ]] && ${mod}_stop ${i} && need_begin=true
		done

		# Delete all the addresses for this alias
		interface_del_addresses ${i} && need_begin=true

		# Do final shut down of this alias
		${need_begin} && einfo "  Stopping ${i}"
		interface_iface_stop ${i}
		eend $?
	done

	return 0
}

# bool start(void)
#
# Brings up ${IFACE}.  Calls preup, iface_start, then postup.
# Returns 0 (success) unless preup or iface_start returns 1 (failure).
# Ignores the return value from postup.
start() {
	local mod
	local -a MODULES

	modules_load ${IFACE}
	eend $?
	[[ 0 != $? ]] && return 1

	if [[ lo == ${IFACE} ]]; then
		ebegin "Bringing ${IFACE} up"
		interface_loopback_create
		eend $?
		return $?
	fi

	# Call user-defined preup function if it exists
	if [[ function == $( type -t preup ) ]]; then
		einfo "Running preup function"
		preup ${IFACE} || {
			eerror "preup ${IFACE} failed"
			return 1
		}
	fi

	# pre Start any modules with
	for mod in ${MODULES[@]}; do
		if [[ function == $( type -t ${mod}_pre_start ) ]]; then
			${mod}_pre_start ${IFACE} || return 1
		fi
	done

	# Start the interface
	if ! iface_start ${IFACE} ; then
		interface_down ${IFACE}
		return 1
	fi

	# post Start modules is called in iface_start
	# as that's where the functions get localised
	# and they may have to call iface_start recursively

	# Call user-defined postup function if it exists
	if [[ function == $( type -t postup ) ]]; then
		einfo "Running postup function"
		postup ${IFACE}
	fi

	return 0
}

# bool stop(void)
#
# Brings down ${IFACE}.  If predown call returns non-zero, then
# stop returns non-zero to indicate failure bringing down device.
# In all other cases stop returns 0 to indicate success.
stop() {
	local mod
	local -a MODULES

	modules_load ${IFACE} true || return 1

	# Call user-defined predown function if it exists
	if [[ lo != ${IFACE} && function == $(type -t predown) ]]; then
		einfo "Running predown function"
		predown ${IFACE} || {
			eerror "predown ${IFACE} failed"
			return 1
		}
	fi

	# pre Stop any modules
	for mod in ${MODULES[@]}; do
		[[ function == $( type -t ${mod}_pre_stop ) ]] && ${mod}_pre_stop ${IFACE}
	done

	iface_stop ${IFACE} || return 1  # always succeeds, btw

	# post Stop any modules
	for mod in ${MODULES[@]}; do
		# We have already taken down the interface, so no need to error
		[[ function == $( type -t ${mod}_post_stop ) ]] && ${mod}_post_stop ${IFACE}
	done

	# Call user-defined postdown function if it exists
	if [[ lo != ${IFACE} && $(type -t postdown) == function ]]; then
		einfo "Running postdown function"
		postdown ${IFACE}
	fi

	return 0
}

# vim:ts=4
