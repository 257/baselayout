#!/bin/bash
# Copyright 1999-2002 Gentoo Technologies, Inc.
# Distributed under the terms of the GNU General Public License, v2 or later
# $Header$

#trap ":" INT QUIT TSTP
source /etc/init.d/functions.sh
umask 022

try() {
	eval $*
	if [ $? -ne 0 ]
	then
		echo -e "$ENDCOL$NORMAL[$BAD oops $NORMAL]"
		echo
		echo '!!! '"ERROR: the $1 command did not complete successfully."
		echo '!!! '"(\" ${*} \")"
		echo '!!! '"Since this is a critical task, startup cannot continue."
		echo
		/sbin/sulogin $CONSOLE
		reboot -f
		fi
}

#save $1
argv1=$1

#first time boot stuff goes here
if [ "$RUNLEVEL" = "S" ] && [ "$argv1" = "boot" ]
then
	echo
	echo -e "${GOOD}Gentoo Linux${GENTOO_VERS}; \e[34;01mhttp://www.gentoo.org${NORMAL}"
	echo -e " Copyright 2001 Gentoo Technologies, Inc.; Distributed under the GPL"
	echo

	ebegin "Mounting /proc"
	try mount -n /proc
	eend $?
	
	devfs="yes"
	get_bootparam "nodevfs"
	if [ $? -eq 0 ]
	then
		devfs="no"
	fi
	
	#fix wierd bug where there is a /dev/.devfsd in a unmounted /dev
	mymounts="`cat /proc/mounts`"
	if [ -e /dev/.devfsd ] && [ "${mymounts/devfs//}" = "${mymounts}" ]
	then
		rm -f /dev/.devfsd
	fi

	#with the new way, /dev can be mounted by the kernel ...
	if [ "$devfs" = "yes" ] && [ ! -e /dev/.devfsd ]
	then
		mymounts="`cat /proc/filesystems`"
		#is devfs support compiled in?
		if [ "${mymounts/devfs//}" != "${mymounts}" ]
		then
			ebegin "Mounting devfs at /dev"; try mount -n -t devfs none /dev; eend
		else
			clear
			echo
			einfo "The Gentoo Linux system initialization scripts have detected that your"
			einfo "kernel has been compiled without DEVFS support.  Because Gentoo Linux"
			einfo "has been designed to work with DEVFS, it is required that you compile"
			einfo "support for it into your kernel.  Please read the 'Gentoo Linux from"
			einfo "source (build) CD Installation Guide' at:"
			echo
			einfo "    http://www.gentoo.org/doc/build.html"
			echo
			einfo "for more information on how to do this."
			echo
			read -t 15 -p "(hit Enter to continue or wait 15 seconds...)"
		fi
	fi

	# need devfsd running now so that /dev/ram0 exists if we need it
	mymounts="`cat /proc/mounts`"
	if [ "$devfs" = "yes" ] && [ -e /dev/.devfsd ] && \
	   [ "${mymounts/devfs//}" != "${mymounts}" ]
	then
		ebegin "Starting devfsd"; /sbin/devfsd /dev >/dev/null 2>&1; eend $?
	fi

	#mount either a ramdisk or tmpfs and do dep scan

	tmpfs="yes"
	get_bootparam "notmpfs"
	if [ $? -eq 0 ]
	then
		tmpfs="no"
	fi

	if [ ! -d $svcdir ]
	then
		mkdir -p $svcdir
	fi
	
	if [ "$tmpfs" = "yes" ] ; then
		ebegin "Mounting tmpfs at ${svcdir}"
		try mount -n -t tmpfs tmpfs ${svcdir} -o rw,mode=0644,size=${svcsize}k
		eend
	else
		ebegin "Mounting ramdisk 0 at ${svcdir}"
		try dd if=/dev/zero of=/dev/ram0 bs=1k count=$svcsize
		try mke2fs -vm0 /dev/ram0 $svcsize
		try mount -n -t ext2 /dev/ram0 ${svcdir} -o rw
		eend
	fi
			
	/etc/init.d/depscan.sh

	#swap needs to be activated *after* devfs has been mounted and *after*
	#devfsd has been started, so that the fstab can be properly parsed

	ebegin "Activating swap"
	swapon -a
	eend

	#set the console loglevel to 1 for a cleaner boot
	#the logger should anyhow dump the ring-0 buffer at start to the
	#logs, and that with dmesg can be used to check for problems
	
	/bin/dmesg -n 1

	#$BOOT can be used by rc-scripts to test if it is the first time
	#the 'boot' runlevel is executed
	
	export BOOT="yes"
	
fi #boot ends here

if [ -z "$argv1" ]
then
	if [ -e ${svcdir}/softlevel ]
	then
		export SOFTLEVEL="`cat ${svcdir}/softlevel`"
	else
		export SOFTLEVEL="boot"
	fi
else
	export SOFTLEVEL=$argv1
fi

#for keeping a list of services that fails during boot/halt
if [ ! -d ${svcdir}/fails ]
then
	mkdir -p ${svcdir}/fails
else
	rm -rf ${svcdir}/fails/*
fi

if [ "$SOFTLEVEL" = "reboot" ] || [ "$SOFTLEVEL" = "shutdown" ]
then
	myscripts=""
elif [ ! -d /etc/runlevels/${SOFTLEVEL} ]
then
	echo "runlevel ${SOFTLEVEL} does not exist; exiting."
	exit 1
else
	myscripts=""
	if [ "$SOFTLEVEL" != "boot" ]
	then
		#normal runlevels *include* boot scripts
		mylevels="/etc/runlevels/${SOFTLEVEL}/* /etc/runlevels/boot/*"
	else
		#non-normal runlevels don't include boot scripts as default
		mylevels="/etc/runlevels/${SOFTLEVEL}/*"
	fi
	for x in $mylevels 
	do
		if [ -L $x ]
		then
			myscripts="$myscripts ${x##*/}"
		fi
	done
fi

#the softscripts dir contains all scripts that belong to the
#runlevel specified in ${svcdir}/softlevel
#it needs to be a new directory, else when stopping the services
#and the old directory is not intact, things get broken

install -d -m0755 ${svcdir}/softscripts.new

for x in $myscripts
do
	if [ ! -e /etc/init.d/${x} ]
	then
		echo "skipping, /etc/init.d/${x} missing"
		continue
	fi
	#the -f eliminates a warning if the symlink already exists, 
	#which can happen if a service is in both the boot level and
	#the current "normal" runlevel
	ln -sf /etc/init.d/${x} ${svcdir}/softscripts.new/${x}
done

dep_stop() {
	local x
	local needsme
	local myservice
	local depservice
	[ ! -L ${1} ] && continue
	if [ ! -e ${1} ]
	then
		#remove dud symlinks
		rm ${1}
		continue
	fi
	myservice=${1##*/}
	
	if [ ! -L ${svcdir}/softscripts.new/${myservice} ]
	then
		#candidate for zapping

		#should not work for 'use'
		if [ ! -d ${svcdir}/need/${myservice} ] #&& [ ! -d ${svcdir}/use/${myservice} ]
		then
			#nothing depends on me
			if [ -L ${svcdir}/started/${myservice} ]
			then
				${1} stop
			fi
		else
			#something may depend on me
			needsme=0
			for mytype in need #use
			do
				for dep in ${svcdir}/${mytype}/${myservice}/*
				do
					if [ -e ${dep} ] && [ -L /${svcdir}/softscripts.new/${dep##*/} ]
					then
						#this dep is valid
						needsme=1
						break
					fi
				done
			done
			if [ $needsme -eq 0 ]
			then
				if [ -L ${svcdir}/started/${myservice} ]
				then
					${1} stop
				fi
			fi
		fi
	fi
}

#stop services
for i in ${svcdir}/started/*
do
	dep_stop $i
done

# Only change softlevel AFTER all the services have been stopped,
# else they will not get the depend's right (wrong SOFTLEVEL)

echo $SOFTLEVEL > ${svcdir}/softlevel

if [ "$SOFTLEVEL" = "reboot" ] || [ "$SOFTLEVEL" = "shutdown" ]
then
	source /etc/init.d/functions.sh
	source /etc/init.d/halt.sh
	if [ "$SOFTLEVEL" = "reboot" ]
	then
		source /etc/init.d/reboot.sh 
	else
		source /etc/init.d/shutdown.sh
	fi
fi

#move the old softscritps directory to a different one
#and make the new softscripts directory the current

mv ${svcdir}/softscripts ${svcdir}/softscripts.old
mv ${svcdir}/softscripts.new/ ${svcdir}/softscripts

dep_start() {
	local x
	local myservice
	local depservice
	if [ ! -L $1 ]
	then
		continue
	fi
	#only start a script if it isn't already running
	myservice=${1##*/}
	if [ ! -L ${svcdir}/started/${myservice} ]
	then
		$1 start
	fi
}
#start scripts
for i in ${svcdir}/softscripts/*
do
	dep_start $i
done

#clean the old runlevel
rm -rf ${svcdir}/softscripts.old

#depends gets newked, so update them
#(this problem should be solved now, but i think it will be a good idea
# to recreate the deps after a change in runlevel)

/etc/init.d/depscan.sh >/dev/null 2>/dev/null

#we want devfsd running after a change of runlevel (this is mostly if we return
#from runlevel 'single')
if [ "`cat /proc/mounts | grep '/dev devfs'`" ] && [ ! "`ps -A |grep devfsd`" ]
then
	/sbin/devfsd /dev >/dev/null 2>&1
fi

#runlevel end, so clear stale fail list
rm -rf ${svcdir}/fails

#if we were in the boot runlevel, it is done now ...
[ -n "$BOOT" ] && unset BOOT

