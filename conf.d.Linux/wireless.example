# /etc/conf.d/wireless:
# Global wireless config file for net.* rc-scripts

##############################################################################
# IMPORTANT
# linux-wlan-ng is not supported as they have their own configuration program
# ensure that /etc/conf.d/net has the entry "!iwconfig" in it's modules line
# Try and use an alternative driver if you need to use this - hostap-driver
# supports non-usb linux-wlan-ng driven devices
##############################################################################

##############################################################################
# HINTS
##############################################################################
# see net.example for using SSID in variable names
#
# Most users will just need to set the following options
# key_SSID1="s:yourkeyhere enc open" # s: means a text key
# key_SSID2="aaaa-bbbb-cccc-dd"      # no s: means a hex key
# preferred_aps="'SSID 1' 'SSID 2'"
#
# Clear? Good. Now configure your wireless network below
#############################################################################

##############################################################################
# SETTINGS
##############################################################################
# Hard code an SSID to an interface - leave this unset if you wish the driver
# to scan for available Access Points
# Set to "any" to connect to any SSID - the driver picks an Access Point
# This needs to be done when the driver doesn't support scanning
# This may work for drivers that don't support scanning but you need automatic
# AP association
# I would only set this as a last resort really - use the preferred_aps
# setting at the bottom of this file

# However, using ad-hoc (without scanning for APs) and master mode
# do require the SSID to be set - do this here
#essid_eth0="any"

# Set the mode of the interface (managed, ad-hoc, master or auto)
# The default is auto
# If it's ad-hoc or master you also may need to specify the channel below
#mode_eth0="auto"

# If managed mode fails, drop to ad-hoc mode with the below SSID?
#adhoc_essid_eth0="WLAN"

# Some drivers/hardware don't scan all that well. We have no control over this
# but we can say how many scans we want to do to try and get a better sweep of
# the area. The default is 1.
#scans_eth0="1"

#Channel can be set (1-14), but defaults to 3 if not set.
#
# The below is taken verbatim from the BSD wavelan documentation found at
# http://www.netbsd.org/Documentation/network/wavelan.html
# There are 14 channels possible; We are told that channels 1-11 are legal for
# North America, channels 1-13 for most of Europe, channels 10-13 for France,
# and only channel 14 for Japan. If in doubt, please refer to the documentation
# that came with your card or access point. Make sure that the channel you
# select is the same channel your access point (or the other card in an ad-hoc
# network) is on. The default for cards sold in North America and most of Europe
# is 3; the default for cards sold in France is 11, and the default for cards
# sold in Japan is 14.
#channel_eth0="3"

# Setup any other config commands. This is basically the iwconfig argument
# without the iwconfig $iface.
#iwconfig_eth0=""

# Set private driver ioctls. This is basically the iwpriv argument without
# the iwpriv $iface. If you use the rt2500 driver (not the rt2x00 one) then
# you can set WPA here, below is an example.
#iwpriv_eth0=""
#iwpriv_SSID=" \
#	'set AuthMode=WPAPSK' \
#	'set EncrypType=TKIP' \
#	'set WPAPSK=yourpasskey' \
#"
#NOTE: Even though you can use WPA like so, you may have to set a WEP key
#if your driver claims the AP is encrypted. The WEP key itself will not be
#used though.

# Seconds to wait before scanning
# Some drivers need to wait until they have finished "loading"
# before they can scan - otherwise they error and claim that they cannot scan
# or resource is unavailable. The default is to wait zero seconds
#sleep_scan_eth0="1"

# Seconds to wait until associated. The default is to wait 10 seconds.
# 0 means wait indefinitely. WARNING: this can cause an infinite delay when
# booting.
#associate_timeout_eth0="5"

# By default a successful association in Managed mode sets the MAC
# address of the AP connected to. However, some drivers (namely
# the ipw2100) don't set an invalid MAC address when association
# fails - so we need to check on link quality which some drivers
# don't report properly either.
# So if you have connection problems try flipping this setting
# Valid options are MAC, quality and all - defaults to MAC
#associate_test_eth0="MAC"

# Some driver/card combinations need to scan in Ad-Hoc mode
# After scanning, the mode is reset to the one defined above
#scan_mode_eth0="Ad-Hoc"

# Below you can define private ioctls to run before and after scanning
# Format is the same as the iwpriv_eth0 above
# This is needed for the HostAP drivers
#iwpriv_scan_pre_eth0="'host_roaming 2'"
#iwpriv_scan_post_eth0="'host_roaming 0'"

# Define a WEP key per SSID or MAC address (of the AP, not your card)
# The encryption type (open or restricted) must match the
# encryption type on the Access Point
# You can't use "any" for an SSID here
#key_SSID="1234-1234-1234-1234-1234-1234-56"
# or you can use strings. Passphrase IS NOT supported
# To use a string, prefix it with s:
# Note - this example also sets the encryption method to open
# which is regarded as more secure than restricted
#key_SSID="s:foobar enc open"
#key_SSID="s:foobar enc restricted"

# If you have whitespace in your key, here's how to set it and use other
# commands like using open encryption.
#key_SSID="s:'foo bar' enc open"

# WEP key for the AP with MAC address 001122334455
#mac_key_001122334455="s:foobar"

# Here are some more examples of keys as some users find others work
# and some don't where they should all do the same thing
#key_SSID="open s:foobar"
#key_SSID="open 1234-5678-9012"
#key_SSID="s:foobar enc open"
#key_SSID="1234-5678-9012 enc open"

# You may want to set muliple keys - here's an example
# It sets 4 keys on the card and instructs to use key 2 by default
#key_SSID="[1] s:passkey1 key [2] s:passkey2 key [3] s:passkey3 key [4] s:passkey4 key [2]"

# You can also override the interface settings found in /etc/conf.d/net
# per SSID - which is very handy if you use different networks a lot
#config_SSID="dhcp"
#dhcpcd_SSID="-t 5"
#routes_SSID=
#fallback_SSID=

# Setting name/domain server causes /etc/resolv.conf to be overwritten
# Note that if DHCP is used, and you want this to take precedence then
# please put -R in your dhcpcd options
#dns_servers_SSID="192.168.0.1 192.168.0.2"
#dns_domain_SSID="some.domain"
#dns_search_path_SSID="search.this.domain search.that.domain"
# Please check the man page for resolv.conf for more information
# as domain and search (searchdomains) are mutually exclusive and
# searchdomains takes precedence

# You can also set any of the /etc/conf.d/net variables per MAC address
# incase you use Access Points with the same SSID but need different
# networking configs. Below is an example - of course you use the same
# method with other variables
#config_001122334455="dhcp"
#dhcpcd_001122334455="-t 10"
#dns_servers_001122334455="192.168.0.1 192.168.0.2"

# Map a MAC address to an SSID
# This is used when the Access Point is not broadcasting it's SSID
# WARNING: This will override the SSID being broadcast due to some
# Access Points sending an SSID even when they have been configured
# not to!
# Change 001122334455 to the MAC address and SSID to the SSID
# it should map to
#mac_essid_001122334455="SSID"

# This lists the preferred SSIDs to connect to in order
# SSID's can contain any characters here as they must match the broadcast
# SSID exactly.
# Surround each SSID with the " character and seperate them with a space
# If the first SSID isn't found then it moves onto the next
# If this isn't defined then it connects to the first one found
#preferred_aps="'SSID 1' 'SSID 2'"

# You can also define a preferred_aps list per interface
#preferred_aps_eth0="'SSID 3' 'SSID 4'"

# You can also say whether we only connect to preferred APs or not
# Values are "any", "preferredonly", "forcepreferred", "forcepreferredonly" and "forceany"
# "any" means it will connect to visible APs in the preferred list and then any
# other available AP
# "preferredonly" means it will only connect to visible APs in the preferred list
# "forcepreferred" means it will forceably connect to APs in order if it does not find
# them in a scan
# "forcepreferredonly" means it forceably connects to the APs in order and does not bother
# to scan
# "forceany" does the same as forcepreferred + connects to any other available AP
# Default is "any"
#associate_order="any"
#associate_order_eth0="any"

# You can define blacklisted Access Points in the same way
#blacklist_aps="'SSID 1' 'SSID 2'"
#blacklist_aps_eth0="'SSID 3' 'SSID 4'"

# If you have more than one wireless card, you can say if you want
# to allow each card to associate with the same Access Point or not
# Values are "yes" and "no"
# Default is "yes"
#unique_ap="yes"
#unique_ap_eth0="yes"

# IMPORTANT: preferred_only, blacklisted_aps and unique_ap only work when
# essid_eth0 is not set and your card is capable of scanning

# NOTE: preferred_aps  list ignores blacklisted_aps - so if you have
# the same SSID in both, well, you're a bit silly :p


##############################################################################
# ADVANCED CONFIGURATION
# 
# Two functions can be defined which will be called surrounding the
# associate function.  The functions are called with the interface
# name first so that one function can control multiple adapters.
#
# The return values for the preassociate function should be 0
# (success) to indicate that configuration or deconfiguration of the
# interface can continue.  If preassociate returns a non-zero value, then
# interface configuration will be aborted.
#
# The return value for the postassociate function is ignored
# since there's nothing to do if it indicates failure.

#preassociate() {
#	# The below adds two configuration variables leap_user_SSID
#	# and leap_pass_SSID. When they are both confiugred for the SSID
#	# being connected to then we run the CISCO LEAP script
#
#	local user pass
#	eval user=\"\$\{leap_user_${SSIDVAR}\}\"
#	eval pass=\"\$\{leap_pass_${SSIDVAR}\}\"
#
#	if [ -n "${user}" -a -n "${pass}" ]; then
#		if [ ! -x /opt/cisco/bin/leapscript ]; then
#			eend "For LEAP support, please emerge net-misc/cisco-aironet-client-utils"
#			return 1
#		fi
#		einfo "Waiting for LEAP Authentication on \"${SSID//\\\\//}\""
#		if /opt/cisco/bin/leapscript ${user} ${pass} | grep -q 'Login incorrect'; then
#			ewarn "Login Failed for ${user}"
#			return 1
#		fi
#	fi
#
#	return 0
#}

#postassociate() {
#	# This function is mostly here for completeness... I haven't
#	# thought of anything nifty to do with it yet ;-)
#	# Return 0 always
#	return 0
#}
